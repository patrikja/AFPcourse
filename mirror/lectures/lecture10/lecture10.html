<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Emil Axelsson" />
  <title>Feldspar: Functional Embedded Language for DSP and Parallelism</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="http://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script type="text/javascript">/*<![CDATA[*/
  /*
  LaTeXMathML.js from http://math.etsu.edu/LaTeXMathML/
  Adapted by Jeff Knisely and Douglas Woodall from ASCIIMathML.js v. 1.4.7,
  (c) 2005 Peter Jipsen http://www.chapman.edu/~jipsen.
  Released under the GNU General Public License version 2 or later.
  See the GNU General Public License (at http://www.gnu.org/copyleft/gpl.html)
  for more details.
  */
  var checkForMathML=true;var notifyIfNoMathML=true;var alertIfNoMathML=false;var mathcolor="";var mathfontfamily="";var showasciiformulaonhover=true;var isIE=document.createElementNS==null;if(document.getElementById==null)
  alert("This webpage requires a recent browser such as \nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")
  function AMcreateElementXHTML(t){if(isIE)return document.createElement(t);else return document.createElementNS("http://www.w3.org/1999/xhtml",t);}
  function AMnoMathMLNote(){var nd=AMcreateElementXHTML("h3");nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));nd.appendChild(document.createTextNode("To view the "));var an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("LaTeXMathML"));an.setAttribute("href","http://www.maths.nott.ac.uk/personal/drw/lm.html");nd.appendChild(an);nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));an=AMcreateElementXHTML("a");an.appendChild(document.createTextNode("MathPlayer"));an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");nd.appendChild(an);nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));nd.appendChild(AMcreateElementXHTML("p"));return nd;}
  function AMisMathMLavailable(){if(navigator.appName.slice(0,8)=="Netscape")
  if(navigator.appVersion.slice(0,1)>="5")return null;else return AMnoMathMLNote();else if(navigator.appName.slice(0,9)=="Microsoft")
  try{var ActiveX=new ActiveXObject("MathPlayer.Factory.1");return null;}catch(e){return AMnoMathMLNote();}
  else return AMnoMathMLNote();}
  var AMcal=[0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];var AMfrk=[0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];var AMbbb=[0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];var CONST=0,UNARY=1,BINARY=2,INFIX=3,LEFTBRACKET=4,RIGHTBRACKET=5,SPACE=6,UNDEROVER=7,DEFINITION=8,TEXT=9,BIG=10,LONG=11,STRETCHY=12,MATRIX=13;var AMsqrt={input:"\\sqrt",tag:"msqrt",output:"sqrt",ttype:UNARY},AMroot={input:"\\root",tag:"mroot",output:"root",ttype:BINARY},AMfrac={input:"\\frac",tag:"mfrac",output:"/",ttype:BINARY},AMover={input:"\\stackrel",tag:"mover",output:"stackrel",ttype:BINARY},AMatop={input:"\\atop",tag:"mfrac",output:"",ttype:INFIX},AMchoose={input:"\\choose",tag:"mfrac",output:"",ttype:INFIX},AMsub={input:"_",tag:"msub",output:"_",ttype:INFIX},AMsup={input:"^",tag:"msup",output:"^",ttype:INFIX},AMtext={input:"\\mathrm",tag:"mtext",output:"text",ttype:TEXT},AMmbox={input:"\\mbox",tag:"mtext",output:"mbox",ttype:TEXT};var AMsymbols=[{input:"\\alpha",tag:"mi",output:"\u03B1",ttype:CONST},{input:"\\beta",tag:"mi",output:"\u03B2",ttype:CONST},{input:"\\gamma",tag:"mi",output:"\u03B3",ttype:CONST},{input:"\\delta",tag:"mi",output:"\u03B4",ttype:CONST},{input:"\\epsilon",tag:"mi",output:"\u03B5",ttype:CONST},{input:"\\varepsilon",tag:"mi",output:"\u025B",ttype:CONST},{input:"\\zeta",tag:"mi",output:"\u03B6",ttype:CONST},{input:"\\eta",tag:"mi",output:"\u03B7",ttype:CONST},{input:"\\theta",tag:"mi",output:"\u03B8",ttype:CONST},{input:"\\vartheta",tag:"mi",output:"\u03D1",ttype:CONST},{input:"\\iota",tag:"mi",output:"\u03B9",ttype:CONST},{input:"\\kappa",tag:"mi",output:"\u03BA",ttype:CONST},{input:"\\lambda",tag:"mi",output:"\u03BB",ttype:CONST},{input:"\\mu",tag:"mi",output:"\u03BC",ttype:CONST},{input:"\\nu",tag:"mi",output:"\u03BD",ttype:CONST},{input:"\\xi",tag:"mi",output:"\u03BE",ttype:CONST},{input:"\\pi",tag:"mi",output:"\u03C0",ttype:CONST},{input:"\\varpi",tag:"mi",output:"\u03D6",ttype:CONST},{input:"\\rho",tag:"mi",output:"\u03C1",ttype:CONST},{input:"\\varrho",tag:"mi",output:"\u03F1",ttype:CONST},{input:"\\varsigma",tag:"mi",output:"\u03C2",ttype:CONST},{input:"\\sigma",tag:"mi",output:"\u03C3",ttype:CONST},{input:"\\tau",tag:"mi",output:"\u03C4",ttype:CONST},{input:"\\upsilon",tag:"mi",output:"\u03C5",ttype:CONST},{input:"\\phi",tag:"mi",output:"\u03C6",ttype:CONST},{input:"\\varphi",tag:"mi",output:"\u03D5",ttype:CONST},{input:"\\chi",tag:"mi",output:"\u03C7",ttype:CONST},{input:"\\psi",tag:"mi",output:"\u03C8",ttype:CONST},{input:"\\omega",tag:"mi",output:"\u03C9",ttype:CONST},{input:"\\Gamma",tag:"mo",output:"\u0393",ttype:CONST},{input:"\\Delta",tag:"mo",output:"\u0394",ttype:CONST},{input:"\\Theta",tag:"mo",output:"\u0398",ttype:CONST},{input:"\\Lambda",tag:"mo",output:"\u039B",ttype:CONST},{input:"\\Xi",tag:"mo",output:"\u039E",ttype:CONST},{input:"\\Pi",tag:"mo",output:"\u03A0",ttype:CONST},{input:"\\Sigma",tag:"mo",output:"\u03A3",ttype:CONST},{input:"\\Upsilon",tag:"mo",output:"\u03A5",ttype:CONST},{input:"\\Phi",tag:"mo",output:"\u03A6",ttype:CONST},{input:"\\Psi",tag:"mo",output:"\u03A8",ttype:CONST},{input:"\\Omega",tag:"mo",output:"\u03A9",ttype:CONST},{input:"\\frac12",tag:"mo",output:"\u00BD",ttype:CONST},{input:"\\frac14",tag:"mo",output:"\u00BC",ttype:CONST},{input:"\\frac34",tag:"mo",output:"\u00BE",ttype:CONST},{input:"\\frac13",tag:"mo",output:"\u2153",ttype:CONST},{input:"\\frac23",tag:"mo",output:"\u2154",ttype:CONST},{input:"\\frac15",tag:"mo",output:"\u2155",ttype:CONST},{input:"\\frac25",tag:"mo",output:"\u2156",ttype:CONST},{input:"\\frac35",tag:"mo",output:"\u2157",ttype:CONST},{input:"\\frac45",tag:"mo",output:"\u2158",ttype:CONST},{input:"\\frac16",tag:"mo",output:"\u2159",ttype:CONST},{input:"\\frac56",tag:"mo",output:"\u215A",ttype:CONST},{input:"\\frac18",tag:"mo",output:"\u215B",ttype:CONST},{input:"\\frac38",tag:"mo",output:"\u215C",ttype:CONST},{input:"\\frac58",tag:"mo",output:"\u215D",ttype:CONST},{input:"\\frac78",tag:"mo",output:"\u215E",ttype:CONST},{input:"\\pm",tag:"mo",output:"\u00B1",ttype:CONST},{input:"\\mp",tag:"mo",output:"\u2213",ttype:CONST},{input:"\\triangleleft",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\triangleright",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\cdot",tag:"mo",output:"\u22C5",ttype:CONST},{input:"\\star",tag:"mo",output:"\u22C6",ttype:CONST},{input:"\\ast",tag:"mo",output:"\u002A",ttype:CONST},{input:"\\times",tag:"mo",output:"\u00D7",ttype:CONST},{input:"\\div",tag:"mo",output:"\u00F7",ttype:CONST},{input:"\\circ",tag:"mo",output:"\u2218",ttype:CONST},{input:"\\bullet",tag:"mo",output:"\u2022",ttype:CONST},{input:"\\oplus",tag:"mo",output:"\u2295",ttype:CONST},{input:"\\ominus",tag:"mo",output:"\u2296",ttype:CONST},{input:"\\otimes",tag:"mo",output:"\u2297",ttype:CONST},{input:"\\bigcirc",tag:"mo",output:"\u25CB",ttype:CONST},{input:"\\oslash",tag:"mo",output:"\u2298",ttype:CONST},{input:"\\odot",tag:"mo",output:"\u2299",ttype:CONST},{input:"\\land",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\wedge",tag:"mo",output:"\u2227",ttype:CONST},{input:"\\lor",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\vee",tag:"mo",output:"\u2228",ttype:CONST},{input:"\\cap",tag:"mo",output:"\u2229",ttype:CONST},{input:"\\cup",tag:"mo",output:"\u222A",ttype:CONST},{input:"\\sqcap",tag:"mo",output:"\u2293",ttype:CONST},{input:"\\sqcup",tag:"mo",output:"\u2294",ttype:CONST},{input:"\\uplus",tag:"mo",output:"\u228E",ttype:CONST},{input:"\\amalg",tag:"mo",output:"\u2210",ttype:CONST},{input:"\\bigtriangleup",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\bigtriangledown",tag:"mo",output:"\u25BD",ttype:CONST},{input:"\\dag",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\dagger",tag:"mo",output:"\u2020",ttype:CONST},{input:"\\ddag",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\ddagger",tag:"mo",output:"\u2021",ttype:CONST},{input:"\\lhd",tag:"mo",output:"\u22B2",ttype:CONST},{input:"\\rhd",tag:"mo",output:"\u22B3",ttype:CONST},{input:"\\unlhd",tag:"mo",output:"\u22B4",ttype:CONST},{input:"\\unrhd",tag:"mo",output:"\u22B5",ttype:CONST},{input:"\\sum",tag:"mo",output:"\u2211",ttype:UNDEROVER},{input:"\\prod",tag:"mo",output:"\u220F",ttype:UNDEROVER},{input:"\\bigcap",tag:"mo",output:"\u22C2",ttype:UNDEROVER},{input:"\\bigcup",tag:"mo",output:"\u22C3",ttype:UNDEROVER},{input:"\\bigwedge",tag:"mo",output:"\u22C0",ttype:UNDEROVER},{input:"\\bigvee",tag:"mo",output:"\u22C1",ttype:UNDEROVER},{input:"\\bigsqcap",tag:"mo",output:"\u2A05",ttype:UNDEROVER},{input:"\\bigsqcup",tag:"mo",output:"\u2A06",ttype:UNDEROVER},{input:"\\coprod",tag:"mo",output:"\u2210",ttype:UNDEROVER},{input:"\\bigoplus",tag:"mo",output:"\u2A01",ttype:UNDEROVER},{input:"\\bigotimes",tag:"mo",output:"\u2A02",ttype:UNDEROVER},{input:"\\bigodot",tag:"mo",output:"\u2A00",ttype:UNDEROVER},{input:"\\biguplus",tag:"mo",output:"\u2A04",ttype:UNDEROVER},{input:"\\int",tag:"mo",output:"\u222B",ttype:CONST},{input:"\\oint",tag:"mo",output:"\u222E",ttype:CONST},{input:":=",tag:"mo",output:":=",ttype:CONST},{input:"\\lt",tag:"mo",output:"<",ttype:CONST},{input:"\\gt",tag:"mo",output:">",ttype:CONST},{input:"\\ne",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\neq",tag:"mo",output:"\u2260",ttype:CONST},{input:"\\le",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leq",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\leqslant",tag:"mo",output:"\u2264",ttype:CONST},{input:"\\ge",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geq",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\geqslant",tag:"mo",output:"\u2265",ttype:CONST},{input:"\\equiv",tag:"mo",output:"\u2261",ttype:CONST},{input:"\\ll",tag:"mo",output:"\u226A",ttype:CONST},{input:"\\gg",tag:"mo",output:"\u226B",ttype:CONST},{input:"\\doteq",tag:"mo",output:"\u2250",ttype:CONST},{input:"\\prec",tag:"mo",output:"\u227A",ttype:CONST},{input:"\\succ",tag:"mo",output:"\u227B",ttype:CONST},{input:"\\preceq",tag:"mo",output:"\u227C",ttype:CONST},{input:"\\succeq",tag:"mo",output:"\u227D",ttype:CONST},{input:"\\subset",tag:"mo",output:"\u2282",ttype:CONST},{input:"\\supset",tag:"mo",output:"\u2283",ttype:CONST},{input:"\\subseteq",tag:"mo",output:"\u2286",ttype:CONST},{input:"\\supseteq",tag:"mo",output:"\u2287",ttype:CONST},{input:"\\sqsubset",tag:"mo",output:"\u228F",ttype:CONST},{input:"\\sqsupset",tag:"mo",output:"\u2290",ttype:CONST},{input:"\\sqsubseteq",tag:"mo",output:"\u2291",ttype:CONST},{input:"\\sqsupseteq",tag:"mo",output:"\u2292",ttype:CONST},{input:"\\sim",tag:"mo",output:"\u223C",ttype:CONST},{input:"\\simeq",tag:"mo",output:"\u2243",ttype:CONST},{input:"\\approx",tag:"mo",output:"\u2248",ttype:CONST},{input:"\\cong",tag:"mo",output:"\u2245",ttype:CONST},{input:"\\Join",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\bowtie",tag:"mo",output:"\u22C8",ttype:CONST},{input:"\\in",tag:"mo",output:"\u2208",ttype:CONST},{input:"\\ni",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\owns",tag:"mo",output:"\u220B",ttype:CONST},{input:"\\propto",tag:"mo",output:"\u221D",ttype:CONST},{input:"\\vdash",tag:"mo",output:"\u22A2",ttype:CONST},{input:"\\dashv",tag:"mo",output:"\u22A3",ttype:CONST},{input:"\\models",tag:"mo",output:"\u22A8",ttype:CONST},{input:"\\perp",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\smile",tag:"mo",output:"\u2323",ttype:CONST},{input:"\\frown",tag:"mo",output:"\u2322",ttype:CONST},{input:"\\asymp",tag:"mo",output:"\u224D",ttype:CONST},{input:"\\notin",tag:"mo",output:"\u2209",ttype:CONST},{input:"\\begin{eqnarray}",output:"X",ttype:MATRIX,invisible:true},{input:"\\begin{array}",output:"X",ttype:MATRIX,invisible:true},{input:"\\\\",output:"}&{",ttype:DEFINITION},{input:"\\end{eqnarray}",output:"}}",ttype:DEFINITION},{input:"\\end{array}",output:"}}",ttype:DEFINITION},{input:"\\big",tag:"mo",output:"X",atval:"1.2",ieval:"2.2",ttype:BIG},{input:"\\Big",tag:"mo",output:"X",atval:"1.6",ieval:"2.6",ttype:BIG},{input:"\\bigg",tag:"mo",output:"X",atval:"2.2",ieval:"3.2",ttype:BIG},{input:"\\Bigg",tag:"mo",output:"X",atval:"2.9",ieval:"3.9",ttype:BIG},{input:"\\left",tag:"mo",output:"X",ttype:LEFTBRACKET},{input:"\\right",tag:"mo",output:"X",ttype:RIGHTBRACKET},{input:"{",output:"{",ttype:LEFTBRACKET,invisible:true},{input:"}",output:"}",ttype:RIGHTBRACKET,invisible:true},{input:"(",tag:"mo",output:"(",atval:"1",ttype:STRETCHY},{input:"[",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\lbrack",tag:"mo",output:"[",atval:"1",ttype:STRETCHY},{input:"\\{",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\lbrace",tag:"mo",output:"{",atval:"1",ttype:STRETCHY},{input:"\\langle",tag:"mo",output:"\u2329",atval:"1",ttype:STRETCHY},{input:"\\lfloor",tag:"mo",output:"\u230A",atval:"1",ttype:STRETCHY},{input:"\\lceil",tag:"mo",output:"\u2308",atval:"1",ttype:STRETCHY},{input:")",tag:"mo",output:")",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"]",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrack",tag:"mo",output:"]",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\}",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rbrace",tag:"mo",output:"}",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rangle",tag:"mo",output:"\u232A",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rfloor",tag:"mo",output:"\u230B",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"\\rceil",tag:"mo",output:"\u2309",rtag:"mi",atval:"1",ttype:STRETCHY},{input:"|",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\|",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\vert",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\Vert",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"\\mid",tag:"mo",output:"\u2223",atval:"1",ttype:STRETCHY},{input:"\\parallel",tag:"mo",output:"\u2225",atval:"1",ttype:STRETCHY},{input:"/",tag:"mo",output:"/",atval:"1.01",ttype:STRETCHY},{input:"\\backslash",tag:"mo",output:"\u2216",atval:"1",ttype:STRETCHY},{input:"\\setminus",tag:"mo",output:"\\",ttype:CONST},{input:"\\!",tag:"mspace",atname:"width",atval:"-0.167em",ttype:SPACE},{input:"\\,",tag:"mspace",atname:"width",atval:"0.167em",ttype:SPACE},{input:"\\>",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\:",tag:"mspace",atname:"width",atval:"0.222em",ttype:SPACE},{input:"\\;",tag:"mspace",atname:"width",atval:"0.278em",ttype:SPACE},{input:"~",tag:"mspace",atname:"width",atval:"0.333em",ttype:SPACE},{input:"\\quad",tag:"mspace",atname:"width",atval:"1em",ttype:SPACE},{input:"\\qquad",tag:"mspace",atname:"width",atval:"2em",ttype:SPACE},{input:"\\prime",tag:"mo",output:"\u2032",ttype:CONST},{input:"'",tag:"mo",output:"\u02B9",ttype:CONST},{input:"''",tag:"mo",output:"\u02BA",ttype:CONST},{input:"'''",tag:"mo",output:"\u2034",ttype:CONST},{input:"''''",tag:"mo",output:"\u2057",ttype:CONST},{input:"\\ldots",tag:"mo",output:"\u2026",ttype:CONST},{input:"\\cdots",tag:"mo",output:"\u22EF",ttype:CONST},{input:"\\vdots",tag:"mo",output:"\u22EE",ttype:CONST},{input:"\\ddots",tag:"mo",output:"\u22F1",ttype:CONST},{input:"\\forall",tag:"mo",output:"\u2200",ttype:CONST},{input:"\\exists",tag:"mo",output:"\u2203",ttype:CONST},{input:"\\Re",tag:"mo",output:"\u211C",ttype:CONST},{input:"\\Im",tag:"mo",output:"\u2111",ttype:CONST},{input:"\\aleph",tag:"mo",output:"\u2135",ttype:CONST},{input:"\\hbar",tag:"mo",output:"\u210F",ttype:CONST},{input:"\\ell",tag:"mo",output:"\u2113",ttype:CONST},{input:"\\wp",tag:"mo",output:"\u2118",ttype:CONST},{input:"\\emptyset",tag:"mo",output:"\u2205",ttype:CONST},{input:"\\infty",tag:"mo",output:"\u221E",ttype:CONST},{input:"\\surd",tag:"mo",output:"\\sqrt{}",ttype:DEFINITION},{input:"\\partial",tag:"mo",output:"\u2202",ttype:CONST},{input:"\\nabla",tag:"mo",output:"\u2207",ttype:CONST},{input:"\\triangle",tag:"mo",output:"\u25B3",ttype:CONST},{input:"\\therefore",tag:"mo",output:"\u2234",ttype:CONST},{input:"\\angle",tag:"mo",output:"\u2220",ttype:CONST},{input:"\\diamond",tag:"mo",output:"\u22C4",ttype:CONST},{input:"\\Diamond",tag:"mo",output:"\u25C7",ttype:CONST},{input:"\\neg",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\lnot",tag:"mo",output:"\u00AC",ttype:CONST},{input:"\\bot",tag:"mo",output:"\u22A5",ttype:CONST},{input:"\\top",tag:"mo",output:"\u22A4",ttype:CONST},{input:"\\square",tag:"mo",output:"\u25AB",ttype:CONST},{input:"\\Box",tag:"mo",output:"\u25A1",ttype:CONST},{input:"\\wr",tag:"mo",output:"\u2240",ttype:CONST},{input:"\\arccos",tag:"mi",output:"arccos",ttype:UNARY,func:true},{input:"\\arcsin",tag:"mi",output:"arcsin",ttype:UNARY,func:true},{input:"\\arctan",tag:"mi",output:"arctan",ttype:UNARY,func:true},{input:"\\arg",tag:"mi",output:"arg",ttype:UNARY,func:true},{input:"\\cos",tag:"mi",output:"cos",ttype:UNARY,func:true},{input:"\\cosh",tag:"mi",output:"cosh",ttype:UNARY,func:true},{input:"\\cot",tag:"mi",output:"cot",ttype:UNARY,func:true},{input:"\\coth",tag:"mi",output:"coth",ttype:UNARY,func:true},{input:"\\csc",tag:"mi",output:"csc",ttype:UNARY,func:true},{input:"\\deg",tag:"mi",output:"deg",ttype:UNARY,func:true},{input:"\\det",tag:"mi",output:"det",ttype:UNARY,func:true},{input:"\\dim",tag:"mi",output:"dim",ttype:UNARY,func:true},{input:"\\exp",tag:"mi",output:"exp",ttype:UNARY,func:true},{input:"\\gcd",tag:"mi",output:"gcd",ttype:UNARY,func:true},{input:"\\hom",tag:"mi",output:"hom",ttype:UNARY,func:true},{input:"\\inf",tag:"mo",output:"inf",ttype:UNDEROVER},{input:"\\ker",tag:"mi",output:"ker",ttype:UNARY,func:true},{input:"\\lg",tag:"mi",output:"lg",ttype:UNARY,func:true},{input:"\\lim",tag:"mo",output:"lim",ttype:UNDEROVER},{input:"\\liminf",tag:"mo",output:"liminf",ttype:UNDEROVER},{input:"\\limsup",tag:"mo",output:"limsup",ttype:UNDEROVER},{input:"\\ln",tag:"mi",output:"ln",ttype:UNARY,func:true},{input:"\\log",tag:"mi",output:"log",ttype:UNARY,func:true},{input:"\\max",tag:"mo",output:"max",ttype:UNDEROVER},{input:"\\min",tag:"mo",output:"min",ttype:UNDEROVER},{input:"\\Pr",tag:"mi",output:"Pr",ttype:UNARY,func:true},{input:"\\sec",tag:"mi",output:"sec",ttype:UNARY,func:true},{input:"\\sin",tag:"mi",output:"sin",ttype:UNARY,func:true},{input:"\\sinh",tag:"mi",output:"sinh",ttype:UNARY,func:true},{input:"\\sup",tag:"mo",output:"sup",ttype:UNDEROVER},{input:"\\tan",tag:"mi",output:"tan",ttype:UNARY,func:true},{input:"\\tanh",tag:"mi",output:"tanh",ttype:UNARY,func:true},{input:"\\gets",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\leftarrow",tag:"mo",output:"\u2190",ttype:CONST},{input:"\\to",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\rightarrow",tag:"mo",output:"\u2192",ttype:CONST},{input:"\\leftrightarrow",tag:"mo",output:"\u2194",ttype:CONST},{input:"\\uparrow",tag:"mo",output:"\u2191",ttype:CONST},{input:"\\downarrow",tag:"mo",output:"\u2193",ttype:CONST},{input:"\\updownarrow",tag:"mo",output:"\u2195",ttype:CONST},{input:"\\Leftarrow",tag:"mo",output:"\u21D0",ttype:CONST},{input:"\\Rightarrow",tag:"mo",output:"\u21D2",ttype:CONST},{input:"\\Leftrightarrow",tag:"mo",output:"\u21D4",ttype:CONST},{input:"\\iff",tag:"mo",output:"~\\Longleftrightarrow~",ttype:DEFINITION},{input:"\\Uparrow",tag:"mo",output:"\u21D1",ttype:CONST},{input:"\\Downarrow",tag:"mo",output:"\u21D3",ttype:CONST},{input:"\\Updownarrow",tag:"mo",output:"\u21D5",ttype:CONST},{input:"\\mapsto",tag:"mo",output:"\u21A6",ttype:CONST},{input:"\\longleftarrow",tag:"mo",output:"\u2190",ttype:LONG},{input:"\\longrightarrow",tag:"mo",output:"\u2192",ttype:LONG},{input:"\\longleftrightarrow",tag:"mo",output:"\u2194",ttype:LONG},{input:"\\Longleftarrow",tag:"mo",output:"\u21D0",ttype:LONG},{input:"\\Longrightarrow",tag:"mo",output:"\u21D2",ttype:LONG},{input:"\\Longleftrightarrow",tag:"mo",output:"\u21D4",ttype:LONG},{input:"\\longmapsto",tag:"mo",output:"\u21A6",ttype:CONST},AMsqrt,AMroot,AMfrac,AMover,AMsub,AMsup,AMtext,AMmbox,AMatop,AMchoose,{input:"\\acute",tag:"mover",output:"\u00B4",ttype:UNARY,acc:true},{input:"\\grave",tag:"mover",output:"\u0060",ttype:UNARY,acc:true},{input:"\\breve",tag:"mover",output:"\u02D8",ttype:UNARY,acc:true},{input:"\\check",tag:"mover",output:"\u02C7",ttype:UNARY,acc:true},{input:"\\dot",tag:"mover",output:".",ttype:UNARY,acc:true},{input:"\\ddot",tag:"mover",output:"..",ttype:UNARY,acc:true},{input:"\\mathring",tag:"mover",output:"\u00B0",ttype:UNARY,acc:true},{input:"\\vec",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overrightarrow",tag:"mover",output:"\u20D7",ttype:UNARY,acc:true},{input:"\\overleftarrow",tag:"mover",output:"\u20D6",ttype:UNARY,acc:true},{input:"\\hat",tag:"mover",output:"\u005E",ttype:UNARY,acc:true},{input:"\\widehat",tag:"mover",output:"\u0302",ttype:UNARY,acc:true},{input:"\\tilde",tag:"mover",output:"~",ttype:UNARY,acc:true},{input:"\\widetilde",tag:"mover",output:"\u02DC",ttype:UNARY,acc:true},{input:"\\bar",tag:"mover",output:"\u203E",ttype:UNARY,acc:true},{input:"\\overbrace",tag:"mover",output:"\uFE37",ttype:UNARY,acc:true},{input:"\\overbracket",tag:"mover",output:"\u23B4",ttype:UNARY,acc:true},{input:"\\overline",tag:"mover",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\underbrace",tag:"munder",output:"\uFE38",ttype:UNARY,acc:true},{input:"\\underbracket",tag:"munder",output:"\u23B5",ttype:UNARY,acc:true},{input:"\\underline",tag:"munder",output:"\u00AF",ttype:UNARY,acc:true},{input:"\\displaystyle",tag:"mstyle",atname:"displaystyle",atval:"true",ttype:UNARY},{input:"\\textstyle",tag:"mstyle",atname:"displaystyle",atval:"false",ttype:UNARY},{input:"\\scriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"1",ttype:UNARY},{input:"\\scriptscriptstyle",tag:"mstyle",atname:"scriptlevel",atval:"2",ttype:UNARY},{input:"\\textrm",tag:"mstyle",output:"\\mathrm",ttype:DEFINITION},{input:"\\mathbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\textbf",tag:"mstyle",atname:"mathvariant",atval:"bold",ttype:UNARY},{input:"\\mathit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\textit",tag:"mstyle",atname:"mathvariant",atval:"italic",ttype:UNARY},{input:"\\mathtt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\texttt",tag:"mstyle",atname:"mathvariant",atval:"monospace",ttype:UNARY},{input:"\\mathsf",tag:"mstyle",atname:"mathvariant",atval:"sans-serif",ttype:UNARY},{input:"\\mathbb",tag:"mstyle",atname:"mathvariant",atval:"double-struck",ttype:UNARY,codes:AMbbb},{input:"\\mathcal",tag:"mstyle",atname:"mathvariant",atval:"script",ttype:UNARY,codes:AMcal},{input:"\\mathfrak",tag:"mstyle",atname:"mathvariant",atval:"fraktur",ttype:UNARY,codes:AMfrk},{input:"\\textcolor",tag:"mstyle",atname:"mathvariant",atval:"mathcolor",ttype:BINARY},{input:"\\colorbox",tag:"mstyle",atname:"mathvariant",atval:"background",ttype:BINARY}];function compareNames(s1,s2){if(s1.input>s2.input)return 1
  else return-1;}
  var AMnames=[];function AMinitSymbols(){AMsymbols.sort(compareNames);for(i=0;i<AMsymbols.length;i++)AMnames[i]=AMsymbols[i].input;}
  var AMmathml="http://www.w3.org/1998/Math/MathML";function AMcreateElementMathML(t){if(isIE)return document.createElement("m:"+t);else return document.createElementNS(AMmathml,t);}
  function AMcreateMmlNode(t,frag){if(isIE)var node=document.createElement("m:"+t);else var node=document.createElementNS(AMmathml,t);node.appendChild(frag);return node;}
  function newcommand(oldstr,newstr){AMsymbols=AMsymbols.concat([{input:oldstr,tag:"mo",output:newstr,ttype:DEFINITION}]);}
  function AMremoveCharsAndBlanks(str,n){var st;st=str.slice(n);for(var i=0;i<st.length&&st.charCodeAt(i)<=32;i=i+1);return st.slice(i);}
  function AMposition(arr,str,n){if(n==0){var h,m;n=-1;h=arr.length;while(n+1<h){m=(n+h)>>1;if(arr[m]<str)n=m;else h=m;}
  return h;}else
  for(var i=n;i<arr.length&&arr[i]<str;i++);return i;}
  function AMgetSymbol(str){var k=0;var j=0;var mk;var st;var tagst;var match="";var more=true;for(var i=1;i<=str.length&&more;i++){st=str.slice(0,i);j=k;k=AMposition(AMnames,st,j);if(k<AMnames.length&&str.slice(0,AMnames[k].length)==AMnames[k]){match=AMnames[k];mk=k;i=match.length;}
  more=k<AMnames.length&&str.slice(0,AMnames[k].length)>=AMnames[k];}
  AMpreviousSymbol=AMcurrentSymbol;if(match!=""){AMcurrentSymbol=AMsymbols[mk].ttype;return AMsymbols[mk];}
  AMcurrentSymbol=CONST;k=1;st=str.slice(0,1);if("0"<=st&&st<="9")tagst="mn";else tagst=(("A">st||st>"Z")&&("a">st||st>"z")?"mo":"mi");return{input:st,tag:tagst,output:st,ttype:CONST};}
  var AMpreviousSymbol,AMcurrentSymbol;function AMparseSexpr(str){var symbol,node,result,result2,i,st,newFrag=document.createDocumentFragment();str=AMremoveCharsAndBlanks(str,0);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];if(symbol.ttype==DEFINITION){str=symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol==null||symbol.ttype==RIGHTBRACKET)
  return[null,str,null];}
  str=AMremoveCharsAndBlanks(str,symbol.input.length);switch(symbol.ttype){case SPACE:node=AMcreateElementMathML(symbol.tag);node.setAttribute(symbol.atname,symbol.atval);return[node,str,symbol.tag];case UNDEROVER:if(isIE){if(symbol.input.substr(0,4)=="\\big"){str="\\"+symbol.input.substr(4)+str;symbol=AMgetSymbol(str);symbol.ttype=UNDEROVER;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];case CONST:var output=symbol.output;if(isIE){if(symbol.input=="'")
  output="\u2032";else if(symbol.input=="''")
  output="\u2033";else if(symbol.input=="'''")
  output="\u2033\u2032";else if(symbol.input=="''''")
  output="\u2033\u2033";else if(symbol.input=="\\square")
  output="\u25A1";else if(symbol.input.substr(0,5)=="\\frac"){var denom=symbol.input.substr(6,1);if(denom=="5"||denom=="6"){str=symbol.input.replace(/\\frac/,"\\frac ")+str;return[node,str,symbol.tag];}}}
  node=AMcreateMmlNode(symbol.tag,document.createTextNode(output));return[node,str,symbol.tag];case LONG:node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));node.setAttribute("minsize","1.5");node.setAttribute("maxsize","1.5");node=AMcreateMmlNode("mover",node);node.appendChild(AMcreateElementMathML("mspace"));return[node,str,symbol.tag];case STRETCHY:if(isIE&&symbol.input=="\\backslash")
  symbol.output="\\";node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(symbol.input=="|"||symbol.input=="\\vert"||symbol.input=="\\|"||symbol.input=="\\Vert"){node.setAttribute("lspace","0em");node.setAttribute("rspace","0em");}
  node.setAttribute("maxsize",symbol.atval);if(symbol.rtag!=null)
  return[node,str,symbol.rtag];else
  return[node,str,symbol.tag];case BIG:var atval=symbol.atval;if(isIE)
  atval=symbol.ieval;symbol=AMgetSymbol(str);if(symbol==null)
  return[null,str,null];str=AMremoveCharsAndBlanks(str,symbol.input.length);node=AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height",atval+"ex");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}else{node.setAttribute("minsize",atval);node.setAttribute("maxsize",atval);}
  return[node,str,symbol.tag];case LEFTBRACKET:if(symbol.input=="\\left"){symbol=AMgetSymbol(str);if(symbol!=null){if(symbol.input==".")
  symbol.invisible=true;str=AMremoveCharsAndBlanks(str,symbol.input.length);}}
  result=AMparseExpr(str,true,false);if(symbol==null||(typeof symbol.invisible=="boolean"&&symbol.invisible))
  node=AMcreateMmlNode("mrow",result[0]);else{node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));node=AMcreateMmlNode("mrow",node);node.appendChild(result[0]);}
  return[node,result[1],result[2]];case MATRIX:if(symbol.input=="\\begin{array}"){var mask="";symbol=AMgetSymbol(str);str=AMremoveCharsAndBlanks(str,0);if(symbol==null)
  mask="l";else{str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="{")
  mask="l";else do{symbol=AMgetSymbol(str);if(symbol!=null){str=AMremoveCharsAndBlanks(str,symbol.input.length);if(symbol.input!="}")
  mask=mask+symbol.input;}}while(symbol!=null&&symbol.input!=""&&symbol.input!="}");}
  result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);mask=mask.replace(/l/g,"left ");mask=mask.replace(/r/g,"right ");mask=mask.replace(/c/g,"center ");node.setAttribute("columnalign",mask);node.setAttribute("displaystyle","false");if(isIE)
  return[node,result[1],null];var lspace=AMcreateElementMathML("mspace");lspace.setAttribute("width","0.167em");var rspace=AMcreateElementMathML("mspace");rspace.setAttribute("width","0.167em");var node1=AMcreateMmlNode("mrow",lspace);node1.appendChild(node);node1.appendChild(rspace);return[node1,result[1],null];}else{result=AMparseExpr("{"+str,true,true);node=AMcreateMmlNode("mtable",result[0]);if(isIE)
  node.setAttribute("columnspacing","0.25em");else
  node.setAttribute("columnspacing","0.167em");node.setAttribute("columnalign","right center left");node.setAttribute("displaystyle","true");node=AMcreateMmlNode("mrow",node);return[node,result[1],null];}
  case TEXT:if(str.charAt(0)=="{")i=str.indexOf("}");else i=0;if(i==-1)
  i=str.length;st=str.slice(1,i);if(st.charAt(0)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  newFrag.appendChild(AMcreateMmlNode(symbol.tag,document.createTextNode(st)));if(st.charAt(st.length-1)==" "){node=AMcreateElementMathML("mspace");node.setAttribute("width","0.33em");newFrag.appendChild(node);}
  str=AMremoveCharsAndBlanks(str,i+1);return[AMcreateMmlNode("mrow",newFrag),str,null];case UNARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str];if(typeof symbol.func=="boolean"&&symbol.func){st=str.charAt(0);if(st=="^"||st=="_"||st==","){return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}else{node=AMcreateMmlNode("mrow",AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node.appendChild(space);}
  node.appendChild(result[0]);return[node,result[1],symbol.tag];}}
  if(symbol.input=="\\sqrt"){if(isIE){var space=AMcreateElementMathML("mspace");space.setAttribute("height","1.2ex");space.setAttribute("width","0em");node=AMcreateMmlNode(symbol.tag,result[0])
  node.appendChild(space);return[node,result[1],symbol.tag];}else
  return[AMcreateMmlNode(symbol.tag,result[0]),result[1],symbol.tag];}else if(typeof symbol.acc=="boolean"&&symbol.acc){node=AMcreateMmlNode(symbol.tag,result[0]);var output=symbol.output;if(isIE){if(symbol.input=="\\hat")
  output="\u0302";else if(symbol.input=="\\widehat")
  output="\u005E";else if(symbol.input=="\\bar")
  output="\u00AF";else if(symbol.input=="\\grave")
  output="\u0300";else if(symbol.input=="\\tilde")
  output="\u0303";}
  var node1=AMcreateMmlNode("mo",document.createTextNode(output));if(symbol.input=="\\vec"||symbol.input=="\\check")
  node1.setAttribute("maxsize","1.2");if(isIE&&symbol.input=="\\bar")
  node1.setAttribute("maxsize","0.5");if(symbol.input=="\\underbrace"||symbol.input=="\\underline")
  node1.setAttribute("accentunder","true");else
  node1.setAttribute("accent","true");node.appendChild(node1);if(symbol.input=="\\overbrace"||symbol.input=="\\underbrace")
  node.ttype=UNDEROVER;return[node,result[1],symbol.tag];}else{if(!isIE&&typeof symbol.codes!="undefined"){for(i=0;i<result[0].childNodes.length;i++)
  if(result[0].childNodes[i].nodeName=="mi"||result[0].nodeName=="mi"){st=(result[0].nodeName=="mi"?result[0].firstChild.nodeValue:result[0].childNodes[i].firstChild.nodeValue);var newst=[];for(var j=0;j<st.length;j++)
  if(st.charCodeAt(j)>64&&st.charCodeAt(j)<91)newst=newst+
  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);else newst=newst+st.charAt(j);if(result[0].nodeName=="mi")
  result[0]=AMcreateElementMathML("mo").appendChild(document.createTextNode(newst));else result[0].replaceChild(AMcreateElementMathML("mo").appendChild(document.createTextNode(newst)),result[0].childNodes[i]);}}
  node=AMcreateMmlNode(symbol.tag,result[0]);node.setAttribute(symbol.atname,symbol.atval);if(symbol.input=="\\scriptstyle"||symbol.input=="\\scriptscriptstyle")
  node.setAttribute("displaystyle","false");return[node,result[1],symbol.tag];}
  case BINARY:result=AMparseSexpr(str);if(result[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];result2=AMparseSexpr(result[1]);if(result2[0]==null)return[AMcreateMmlNode("mo",document.createTextNode(symbol.input)),str,null];if(symbol.input=="\\textcolor"||symbol.input=="\\colorbox"){var tclr=str.match(/\{\s*([#\w]+)\s*\}/);str=str.replace(/\{\s*[#\w]+\s*\}/,"");if(tclr!=null){if(IsColorName.test(tclr[1].toLowerCase())){tclr=LaTeXColor[tclr[1].toLowerCase()];}else{tclr=tclr[1];}
  node=AMcreateElementMathML("mstyle");node.setAttribute(symbol.atval,tclr);node.appendChild(result2[0]);return[node,result2[1],symbol.tag];}}
  if(symbol.input=="\\root"||symbol.input=="\\stackrel")newFrag.appendChild(result2[0]);newFrag.appendChild(result[0]);if(symbol.input=="\\frac")newFrag.appendChild(result2[0]);return[AMcreateMmlNode(symbol.tag,newFrag),result2[1],symbol.tag];case INFIX:str=AMremoveCharsAndBlanks(str,symbol.input.length);return[AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str,symbol.tag];default:return[AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)),str,symbol.tag];}}
  function AMparseIexpr(str){var symbol,sym1,sym2,node,result,tag,underover;str=AMremoveCharsAndBlanks(str,0);sym1=AMgetSymbol(str);result=AMparseSexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(symbol.ttype==INFIX){str=AMremoveCharsAndBlanks(str,symbol.input.length);result=AMparseSexpr(str);if(result[0]==null)
  result[0]=AMcreateMmlNode("mo",document.createTextNode("\u25A1"));str=result[1];tag=result[2];if(symbol.input=="_"||symbol.input=="^"){sym2=AMgetSymbol(str);tag=null;underover=((sym1.ttype==UNDEROVER)||(node.ttype==UNDEROVER));if(symbol.input=="_"&&sym2.input=="^"){str=AMremoveCharsAndBlanks(str,sym2.input.length);var res2=AMparseSexpr(str);str=res2[1];tag=res2[2];node=AMcreateMmlNode((underover?"munderover":"msubsup"),node);node.appendChild(result[0]);node.appendChild(res2[0]);}else if(symbol.input=="_"){node=AMcreateMmlNode((underover?"munder":"msub"),node);node.appendChild(result[0]);}else{node=AMcreateMmlNode((underover?"mover":"msup"),node);node.appendChild(result[0]);}
  node=AMcreateMmlNode("mrow",node);}else{node=AMcreateMmlNode(symbol.tag,node);if(symbol.input=="\\atop"||symbol.input=="\\choose")
  node.setAttribute("linethickness","0ex");node.appendChild(result[0]);if(symbol.input=="\\choose")
  node=AMcreateMmlNode("mfenced",node);}}
  return[node,str,tag];}
  function AMparseExpr(str,rightbracket,matrix){var symbol,node,result,i,tag,newFrag=document.createDocumentFragment();do{str=AMremoveCharsAndBlanks(str,0);result=AMparseIexpr(str);node=result[0];str=result[1];tag=result[2];symbol=AMgetSymbol(str);if(node!=undefined){if((tag=="mn"||tag=="mi")&&symbol!=null&&typeof symbol.func=="boolean"&&symbol.func){var space=AMcreateElementMathML("mspace");space.setAttribute("width","0.167em");node=AMcreateMmlNode("mrow",node);node.appendChild(space);}
  newFrag.appendChild(node);}}while((symbol.ttype!=RIGHTBRACKET)&&symbol!=null&&symbol.output!="");tag=null;if(symbol.ttype==RIGHTBRACKET){if(symbol.input=="\\right"){str=AMremoveCharsAndBlanks(str,symbol.input.length);symbol=AMgetSymbol(str);if(symbol!=null&&symbol.input==".")
  symbol.invisible=true;if(symbol!=null)
  tag=symbol.rtag;}
  if(symbol!=null)
  str=AMremoveCharsAndBlanks(str,symbol.input.length);var len=newFrag.childNodes.length;if(matrix&&len>0&&newFrag.childNodes[len-1].nodeName=="mrow"&&len>1&&newFrag.childNodes[len-2].nodeName=="mo"&&newFrag.childNodes[len-2].firstChild.nodeValue=="&"){var pos=[];var m=newFrag.childNodes.length;for(i=0;matrix&&i<m;i=i+2){pos[i]=[];node=newFrag.childNodes[i];for(var j=0;j<node.childNodes.length;j++)
  if(node.childNodes[j].firstChild.nodeValue=="&")
  pos[i][pos[i].length]=j;}
  var row,frag,n,k,table=document.createDocumentFragment();for(i=0;i<m;i=i+2){row=document.createDocumentFragment();frag=document.createDocumentFragment();node=newFrag.firstChild;n=node.childNodes.length;k=0;for(j=0;j<n;j++){if(typeof pos[i][k]!="undefined"&&j==pos[i][k]){node.removeChild(node.firstChild);row.appendChild(AMcreateMmlNode("mtd",frag));k++;}else frag.appendChild(node.firstChild);}
  row.appendChild(AMcreateMmlNode("mtd",frag));if(newFrag.childNodes.length>2){newFrag.removeChild(newFrag.firstChild);newFrag.removeChild(newFrag.firstChild);}
  table.appendChild(AMcreateMmlNode("mtr",row));}
  return[table,str];}
  if(typeof symbol.invisible!="boolean"||!symbol.invisible){node=AMcreateMmlNode("mo",document.createTextNode(symbol.output));newFrag.appendChild(node);}}
  return[newFrag,str,tag];}
  function AMparseMath(str){var result,node=AMcreateElementMathML("mstyle");var cclr=str.match(/\\color\s*\{\s*([#\w]+)\s*\}/);str=str.replace(/\\color\s*\{\s*[#\w]+\s*\}/g,"");if(cclr!=null){if(IsColorName.test(cclr[1].toLowerCase())){cclr=LaTeXColor[cclr[1].toLowerCase()];}else{cclr=cclr[1];}
  node.setAttribute("mathcolor",cclr);}else{if(mathcolor!="")node.setAttribute("mathcolor",mathcolor);};if(mathfontfamily!="")node.setAttribute("fontfamily",mathfontfamily);node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false,false)[0]);node=AMcreateMmlNode("math",node);if(showasciiformulaonhover)
  node.setAttribute("title",str.replace(/\s+/g," "));if(false){var fnode=AMcreateElementXHTML("font");fnode.setAttribute("face",mathfontfamily);fnode.appendChild(node);return fnode;}
  return node;}
  function AMstrarr2docFrag(arr,linebreaks){var newFrag=document.createDocumentFragment();var expr=false;for(var i=0;i<arr.length;i++){if(expr)newFrag.appendChild(AMparseMath(arr[i]));else{var arri=(linebreaks?arr[i].split("\n\n"):[arr[i]]);newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[0])));for(var j=1;j<arri.length;j++){newFrag.appendChild(AMcreateElementXHTML("p"));newFrag.appendChild(AMcreateElementXHTML("span").appendChild(document.createTextNode(arri[j])));}}
  expr=!expr;}
  return newFrag;}
  function AMprocessNodeR(n,linebreaks){var mtch,str,arr,frg,i;if(n.childNodes.length==0){if((n.nodeType!=8||linebreaks)&&n.parentNode.nodeName!="form"&&n.parentNode.nodeName!="FORM"&&n.parentNode.nodeName!="textarea"&&n.parentNode.nodeName!="TEXTAREA"&&n.parentNode.nodeName!="pre"&&n.parentNode.nodeName!="PRE"){str=n.nodeValue;if(!(str==null)){str=str.replace(/\r\n\r\n/g,"\n\n");str=str.replace(/\x20+/g," ");str=str.replace(/\s*\r\n/g," ");mtch=(str.indexOf("\$")==-1?false:true);str=str.replace(/([^\\])\$/g,"$1 \$");str=str.replace(/^\$/," \$");arr=str.split(" \$");for(i=0;i<arr.length;i++)
  arr[i]=arr[i].replace(/\\\$/g,"\$");if(arr.length>1||mtch){if(checkForMathML){checkForMathML=false;var nd=AMisMathMLavailable();AMnoMathML=nd!=null;if(AMnoMathML&&notifyIfNoMathML)
  if(alertIfNoMathML)
  alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\nor Firefox/Mozilla/Netscape");else AMbody.insertBefore(nd,AMbody.childNodes[0]);}
  if(!AMnoMathML){frg=AMstrarr2docFrag(arr,n.nodeType==8);var len=frg.childNodes.length;n.parentNode.replaceChild(frg,n);return len-1;}else return 0;}}}else return 0;}else if(n.nodeName!="math"){for(i=0;i<n.childNodes.length;i++)
  i+=AMprocessNodeR(n.childNodes[i],linebreaks);}
  return 0;}
  function AMprocessNode(n,linebreaks,spanclassAM){var frag,st;if(spanclassAM!=null){frag=document.getElementsByTagName("span")
  for(var i=0;i<frag.length;i++)
  if(frag[i].className=="AM")
  AMprocessNodeR(frag[i],linebreaks);}else{try{st=n.innerHTML;}catch(err){}
  if(st==null||st.indexOf("\$")!=-1)
  AMprocessNodeR(n,linebreaks);}
  if(isIE){frag=document.getElementsByTagName('math');for(var i=0;i<frag.length;i++)frag[i].update()}}
  var inAppendix=false;var sectionCntr=0;var IEcommentWarning=true;var biblist=[];var bibcntr=0;var LaTeXCounter=[];LaTeXCounter["definition"]=0;LaTeXCounter["proposition"]=0;LaTeXCounter["lemma"]=0;LaTeXCounter["theorem"]=0;LaTeXCounter["corollary"]=0;LaTeXCounter["example"]=0;LaTeXCounter["exercise"]=0;LaTeXCounter["subsection"]=0;LaTeXCounter["subsubsection"]=0;LaTeXCounter["figure"]=0;LaTeXCounter["equation"]=0;LaTeXCounter["table"]=0;var LaTeXColor=[];LaTeXColor["greenyellow"]="#D9FF4F";LaTeXColor["yellow"]="#FFFF00";LaTeXColor["goldenrod"]="#FFE529";LaTeXColor["dandelion"]="#FFB529";LaTeXColor["apricot"]="#FFAD7A";LaTeXColor["peach"]="#FF804D";LaTeXColor["melon"]="#FF8A80";LaTeXColor["yelloworange"]="#FF9400";LaTeXColor["orange"]="#FF6321";LaTeXColor["burntorange"]="#FF7D00";LaTeXColor["bittersweet"]="#C20300";LaTeXColor["redorange"]="#FF3B21";LaTeXColor["mahogany"]="#A60000";LaTeXColor["maroon"]="#AD0000";LaTeXColor["brickred"]="#B80000";LaTeXColor["red"]="#FF0000";LaTeXColor["orangered"]="#FF0080";LaTeXColor["rubinered"]="#FF00DE";LaTeXColor["wildstrawberry"]="#FF0A9C";LaTeXColor["salmon"]="#FF789E";LaTeXColor["carnationpink"]="#FF5EFF";LaTeXColor["magenta"]="#FF00FF";LaTeXColor["violetred"]="#FF30FF";LaTeXColor["rhodamine"]="#FF2EFF";LaTeXColor["mulberry"]="#A314FA";LaTeXColor["redviolet"]="#9600A8";LaTeXColor["fuchsia"]="#7303EB";LaTeXColor["lavender"]="#FF85FF";LaTeXColor["thistle"]="#E069FF";LaTeXColor["orchid"]="#AD5CFF";LaTeXColor["darkorchid"]="#9933CC";LaTeXColor["purple"]="#8C24FF";LaTeXColor["plum"]="#8000FF";LaTeXColor["violet"]="#361FFF";LaTeXColor["royalpurple"]="#401AFF";LaTeXColor["blueviolet"]="#1A0DF5";LaTeXColor["periwinkle"]="#6E73FF";LaTeXColor["cadetblue"]="#616EC4";LaTeXColor["cornflowerblue"]="#59DEFF";LaTeXColor["midnightblue"]="#007091";LaTeXColor["navyblue"]="#0F75FF";LaTeXColor["royalblue"]="#0080FF";LaTeXColor["blue"]="#0000FF";LaTeXColor["cerulean"]="#0FE3FF";LaTeXColor["cyan"]="#00FFFF";LaTeXColor["processblue"]="#0AFFFF";LaTeXColor["skyblue"]="#61FFE0";LaTeXColor["turquoise"]="#26FFCC";LaTeXColor["tealblue"]="#1FFAA3";LaTeXColor["aquamarine"]="#2EFFB2";LaTeXColor["bluegreen"]="#26FFAB";LaTeXColor["emerald"]="#00FF80";LaTeXColor["junglegreen"]="#03FF7A";LaTeXColor["seagreen"]="#4FFF80";LaTeXColor["green"]="#00FF00";LaTeXColor["forestgreen"]="#00E000";LaTeXColor["pinegreen"]="#00BF29";LaTeXColor["limegreen"]="#80FF00";LaTeXColor["yellowgreen"]="#8FFF42";LaTeXColor["springgreen"]="#BDFF3D";LaTeXColor["olivegreen"]="#009900";LaTeXColor["rawsienna"]="#8C0000";LaTeXColor["sepia"]="#4D0000";LaTeXColor["brown"]="#660000";LaTeXColor["tan"]="#DB9470";LaTeXColor["gray"]="#808080";LaTeXColor["grey"]="#808080";LaTeXColor["black"]="#000000";LaTeXColor["white"]="#FFFFFF";var IsColorName=/^(?:greenyellow|yellow|goldenrod|dandelion|apricot|peach|melon|yelloworange|orange|burntorange|bittersweet|redorange|mahogany|maroon|brickred|red|orangered|rubinered|wildstrawberry|salmon|carnationpink|magenta|violetred|rhodamine|mulberry|redviolet|fuchsia|lavender|thistle|orchid|darkorchid|purple|plum|violet|royalpurple|blueviolet|periwinkle|cadetblue|cornflowerblue|midnightblue|navyblue|royalblue|blue|cerulean|cyan|processblue|skyblue|turquoise|tealblue|aquamarine|bluegreen|emerald|junglegreen|seagreen|green|forestgreen|pinegreen|limegreen|yellowgreen|springgreen|olivegreen|rawsienna|sepia|brown|tan|gray|grey|black|white)$/;var IsCounter=/^(?:definition|proposition|lemma|theorem|corollary|example|exercise|subsection|subsubsection|figure|equation|table)$/;var IsLaTeXElement=/^(?:displayequation|title|author|address|date|abstract|keyword|section|subsection|subsubsection|ref|cite|thebibliography|definition|proposition|lemma|theorem|corollary|example|exercise|itemize|enumerate|enddefinition|endproposition|endlemma|endtheorem|endcorollary|endexample|endexercise|enditemize|endenumerate|LaTeXMathMLlabel|LaTeXMathML|smallskip|medskip|bigskip|quote|quotation|endquote|endquotation|center|endcenter|description|enddescription|inlinemath)$/;var IsTextOnlyArea=/^(?:form|textarea|pre)$/i;var tableid=0;function makeNumberString(cntr){if(sectionCntr>0){if(inAppendix){return"A"+sectionCntr+"."+cntr;}else{return sectionCntr+"."+cntr;}}else{return""+cntr;}};function LaTeXpreProcess(thebody){var TheBody=thebody;if(TheBody.hasChildNodes()){if(!(IsLaTeXElement.test(TheBody.className)))
  {for(var i=0;i<TheBody.childNodes.length;i++){LaTeXpreProcess(TheBody.childNodes[i])}}}
  else{if(TheBody.nodeType==3&&!(IsTextOnlyArea.test(TheBody.parentNode.nodeName)))
  {var str=TheBody.nodeValue;if(!(str==null)){str=str.replace(/\\%/g,"<per>");str=str.replace(/%[^\n]*(?=\n)/g,"");str=str.replace(/%[^\r]*(?=\r)/g,"");str=str.replace(/%[^\n]*$/,"")
  if(isIE&&str.match(/%/g)!=null&&IEcommentWarning){alert("Comments may not have parsed properly.  Try putting in <pre class='LaTeX><div>..</div></pre> structure.");IEcommentWarning=false;}
  str=str.replace(/<per>/g,"%");if(str.match(/XXX[\s\S]*/)!=null){var tmp=str.match(/XXX[\s\S]*/)[0];var tmpstr=tmp.charCodeAt(7)+"::"+tmp.charCodeAt(8)+"::"+tmp.charCodeAt(9)+"::"+tmp.charCodeAt(10)+"::"+tmp.charCodeAt(11)+"::"+tmp.charCodeAt(12)+"::"+tmp.charCodeAt(13);alert(tmpstr);}
  str=str.replace(/([^\\])\\(\s)/g,"$1\u00A0$2");str=str.replace(/\\quad/g,"\u2001");str=str.replace(/\\qquad/g,"\u2001\u2001");str=str.replace(/\\enspace/g,"\u2002");str=str.replace(/\\;/g,"\u2004");str=str.replace(/\\:/g,"\u2005");str=str.replace(/\\,/g,"\u2006");str=str.replace(/\\thinspace/g,"\u200A");str=str.replace(/([^\\])~/g,"$1\u00A0");str=str.replace(/\\~/g,"~");str=str.replace(/\\\[/g," <DEQ> $\\displaystyle{");str=str.replace(/\\\]/g,"}$ <DEQ> ");str=str.replace(/\$\$/g,"${$<DEQ>$}$");str=str.replace(/\\begin\s*\{\s*array\s*\}/g,"\\begin{array}");str=str.replace(/\\end\s*\{\s*array\s*\}/g,"\\end{array}");str=str.replace(/\\begin\s*\{\s*eqnarray\s*\}/g,"  <DEQ>eqno$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*eqnarray\*\s*\}/g,"  <DEQ>$\\begin{eqnarray}");str=str.replace(/\\end\s*\{\s*eqnarray\*\s*\}/g,"\\end{eqnarray}$<DEQ>  ");str=str.replace(/\\begin\s*\{\s*displaymath\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*displaymath\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\*\s*\}/g," <DEQ> $\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\*\s*\}/g,"}$ <DEQ> ");str=str.replace(/\\begin\s*\{\s*equation\s*\}/g," <DEQ>eqno$\\displaystyle{");str=str.replace(/\\end\s*\{\s*equation\s*\}/g,"}$ <DEQ> ");str=str.split("<DEQ>");var newFrag=document.createDocumentFragment();for(var i=0;i<str.length;i++){if(i%2){var DEQtable=document.createElement("table");DEQtable.className='displayequation';var DEQtbody=document.createElement("tbody");var DEQtr=document.createElement("tr");var DEQtdeq=document.createElement("td");DEQtdeq.className='eq';str[i]=str[i].replace(/\$\}\$/g,"$\\displaystyle{");str[i]=str[i].replace(/\$\{\$/g,"}");var lbl=str[i].match(/\\label\s*\{\s*(\w+)\s*\}/);var ISeqno=str[i].match(/^eqno/);str[i]=str[i].replace(/^eqno/," ");str[i]=str[i].replace(/\\label\s*\{\s*\w+\s*\}/," ");DEQtdeq.appendChild(document.createTextNode(str[i]));DEQtr.appendChild(DEQtdeq);str[i]=str[i].replace(/\\nonumber/g,"");if(ISeqno!=null||lbl!=null){var DEQtdno=document.createElement("td");DEQtdno.className='eqno';LaTeXCounter["equation"]++;var eqnoString=makeNumberString(LaTeXCounter["equation"]);var DEQanchor=document.createElement("a");if(lbl!=null){DEQanchor.id=lbl[1]};DEQanchor.className="eqno";var anchorSpan=document.createElement("span");anchorSpan.className="eqno";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(eqnoString));DEQanchor.appendChild(anchorSpan);DEQtdno.appendChild(DEQanchor);var DEQspan=document.createElement("span");DEQspan.className="eqno";DEQspan.appendChild(document.createTextNode("("+eqnoString+")"));DEQtdno.appendChild(DEQspan);DEQtr.appendChild(DEQtdno);}
  DEQtbody.appendChild(DEQtr);DEQtable.appendChild(DEQtbody);newFrag.appendChild(DEQtable);}
  else{str[i]=str[i].replace(/\$\}\$/g,"");str[i]=str[i].replace(/\$\{\$/g,"");str[i]=str[i].replace(/\\maketitle/g,"");str[i]=str[i].replace(/\\begin\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\end\s*\{\s*document\s*\}/g,"");str[i]=str[i].replace(/\\documentclass[^\}]*?\}/g,"");str[i]=str[i].replace(/\\usepackage[^\}]*?\}/g,"");str[i]=str[i].replace(/\\noindent/g,"");str[i]=str[i].replace(/\\notag/g,"");str[i]=str[i].replace(/\\ref\s*\{\s*(\w+)\}/g," \\[ref\\]$1\\[ ");str[i]=str[i].replace(/\\url\s*\{\s*([^\}\n]+)\}/g," \\[url\\]$1\\[ ");str[i]=str[i].replace(/\\href\s*\{\s*([^\}]+)\}\s*\{\s*([^\}]+)\}/g," \\[href\\]$1\\]$2\\[ ");str[i]=str[i].replace(/\\cite\s*\{\s*(\w+)\}/g," \\[cite\\]$1\\[ ");str[i]=str[i].replace(/\\qed/g,"\u220E");str[i]=str[i].replace(/\\endproof/g,"\u220E");str[i]=str[i].replace(/\\proof/g,"\\textbf{Proof: }");str[i]=str[i].replace(/\\n(?=\s)/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\newline/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\linebreak/g," \\[br\\] \\[ ");str[i]=str[i].replace(/\\smallskip/g," \\[logicalbreak\\]smallskip\\[ ");str[i]=str[i].replace(/\\medskip/g," \\[logicalbreak\\]medskip\\[ ");str[i]=str[i].replace(/\\bigskip/g," \\[logicalbreak\\]bigskip\\[ ");str[i]=str[i].replace(/[\n\r]+[ \f\n\r\t\v\u2028\u2029]*[\n\r]+/g," \\[logicalbreak\\]LaTeXMathML\\[ ");if(isIE){str[i]=str[i].replace(/\r/g," ");}
  str[i]=str[i].replace(/\\bibitem\s*([^\{]*\{\s*\w*\s*\})/g," \\[bibitem\\]$1\\[ ");str[i]=str[i].replace(/\\bibitem\s*/g," \\[bibitem\\] \\[ ");str[i]=str[i].replace(/\\item\s*\[\s*(\w+)\s*\]/g," \\[alistitem\\]$1\\[ ");str[i]=str[i].replace(/\\item\s*/g," \\[alistitem\\] \\[ ");str[i]=str[i].replace(/\\appendix/g," \\[appendix\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*figure\s*\}([\s\S]+?)\\end\s*\{\s*figure\s*\}/g," \\[figure\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*table\s*\}([\s\S]+?)\\end\s*\{\s*table\s*\}/g," \\[table\\]$1\\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*theorem\s*\}/g," \\[theorem\\]Theorem \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*theorem\s*\}/g," \\[endtheorem\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*definition\s*\}/g," \\[definition\\]Definition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*definition\s*\}/g," \\[enddefinition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*lemma\s*\}/g," \\[lemma\\]Lemma \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*lemma\s*\}/g," \\[endlemma\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*corollary\s*\}/g," \\[corollary\\]Corollary \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*corollary\s*\}/g," \\[endcorollary\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proposition\s*\}/g," \\[proposition\\]Proposition \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*proposition\s*\}/g," \\[endproposition\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*example\s*\}/g," \\[example\\]Example \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*example\s*\}/g," \\[endexample\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*exercise\s*\}/g," \\[exercise\\]Exercise \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*exercise\s*\}/g," \\[endexercise\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}\s*\{\s*\w+\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*thebibliography\s*\}/g," \\[thebibliography\\]References \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*thebibliography\s*\}/g," \\[endthebibliography\\]References \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*proof\s*\}/g," \\[proof\\]Proof: \\[ ");if(isIE){str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g,"\u220E \\[endproof\\] \\[ ");}else{str[i]=str[i].replace(/\\end\s*\{\s*proof\s*\}/g," \\[endproof\\] \\[ ");}
  str[i]=str[i].replace(/\\title\s*\{\s*([^\}]+)\}/g," \\[title\\] \\[$1 \\[endtitle\\] \\[ ");str[i]=str[i].replace(/\\author\s*\{\s*([^\}]+)\}/g," \\[author\\] \\[$1 \\[endauthor\\] \\[ ");str[i]=str[i].replace(/\\address\s*\{\s*([^\}]+)\}/g," \\[address\\] \\[$1 \\[endaddress\\] \\[ ");str[i]=str[i].replace(/\\date\s*\{\s*([^\}]+)\}/g," \\[date\\] \\[$1 \\[enddate\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*keyword\s*\}/g," \\[keyword\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*keyword\s*\}/g," \\[endkeyword\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*abstract\s*\}/g," \\[abstract\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*abstract\s*\}/g," \\[endabstract\\] \\[ ");str[i]=str[i].replace(/\\begin\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[$1\\] \\[ ");str[i]=str[i].replace(/\\end\s*\{\s*(?!array|tabular)(\w+)\s*\}/g," \\[end$1\\] \\[ ");var sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\section\s*\{/," \\[section\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\section\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsection\s*\{/," \\[subsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsection\s*\{\s*[\s\S]+\}/);}
  sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);while(sectionIndex>=0){str[i]=str[i].replace(/\\subsubsection\s*\{/," \\[subsubsection\\]");var delimcnt=1;for(var ii=sectionIndex;ii<str[i].length;ii++){if(str[i].charAt(ii)=="{"){delimcnt++};if(str[i].charAt(ii)=="}"){delimcnt--};if(delimcnt==0){str[i]=str[i].substring(0,ii)+"\\[ "+str[i].substring(ii+1,str[i].length);break;}};sectionIndex=str[i].search(/\\subsubsection\s*\{\s*[\s\S]+\}/);}
  var CatToNextEven="";var strtmp=str[i].split("\\[");for(var j=0;j<strtmp.length;j++){if(j%2){var strtmparray=strtmp[j].split("\\]");switch(strtmparray[0]){case"section":var nodeTmp=document.createElement("H2");nodeTmp.className='section';sectionCntr++;for(var div in LaTeXCounter){LaTeXCounter[div]=0};var nodeAnchor=document.createElement("a");if(inAppendix){nodeAnchor.className='appendixsection';}else{nodeAnchor.className='section';}
  var nodeNumString=makeNumberString("");var anchorSpan=document.createElement("span");anchorSpan.className="section";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='section';nodeSpan.appendChild(document.createTextNode(nodeNumString+" "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsection":var nodeTmp=document.createElement("H3");nodeTmp.className='subsection';LaTeXCounter["subsection"]++;LaTeXCounter["subsubsection"]=0;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"subsubsection":var nodeTmp=document.createElement("H4");nodeTmp.className='subsubsection';LaTeXCounter["subsubsection"]++;var nodeAnchor=document.createElement("a");nodeAnchor.className='subsubsection';var nodeNumString=makeNumberString(LaTeXCounter["subsection"]+"."+LaTeXCounter["subsubsection"]);var anchorSpan=document.createElement("span");anchorSpan.className="subsubsection";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(nodeNumString));nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className='subsubsection';nodeSpan.appendChild(document.createTextNode(nodeNumString+". "));nodeTmp.appendChild(nodeSpan);nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"href":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"url":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathML';nodeTmp.href=strtmparray[1];nodeTmp.appendChild(document.createTextNode(strtmparray[1]));newFrag.appendChild(nodeTmp);break;case"figure":var nodeTmp=document.createElement("table");nodeTmp.className='figure';var FIGtbody=document.createElement("tbody");var FIGlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var FIGcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;FIGcap=tmp.substring(capstart,pos);break}}}
  var FIGtr2=document.createElement("tr");var FIGtd2=document.createElement("td");FIGtd2.className="caption";var FIGanchor=document.createElement("a");FIGanchor.className="figure";if(FIGlbl!=null){FIGanchor.id=FIGlbl[1];}
  LaTeXCounter["figure"]++;var fignmbr=makeNumberString(LaTeXCounter["figure"]);var anchorSpan=document.createElement("span");anchorSpan.className="figure";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(fignmbr));FIGanchor.appendChild(anchorSpan);FIGtd2.appendChild(FIGanchor);var FIGspan=document.createElement("span");FIGspan.className="figure";FIGspan.appendChild(document.createTextNode("Figure "+fignmbr+". "));FIGtd2.appendChild(FIGspan);FIGtd2.appendChild(document.createTextNode(""+FIGcap));FIGtr2.appendChild(FIGtd2);FIGtbody.appendChild(FIGtr2);var IsSpecial=false;var FIGinfo=strtmparray[1].match(/\\includegraphics\s*\{([^\}]+)\}/);if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\includegraphics\s*\[[^\]]*\]\s*\{\s*([^\}]+)\s*\}/);}
  if(FIGinfo==null){FIGinfo=strtmparray[1].match(/\\special\s*\{\s*([^\}]+)\}/);IsSpecial=true};if(FIGinfo!=null){var FIGtr1=document.createElement("tr");var FIGtd1=document.createElement("td");FIGtd1.className="image";var FIGimg=document.createElement("img");var FIGsrc=FIGinfo[1];FIGimg.src=FIGsrc;FIGimg.alt="Figure "+FIGsrc+" did not load";FIGimg.title="Figure "+fignmbr+". "+FIGcap;FIGimg.id="figure"+fignmbr;FIGtd1.appendChild(FIGimg);FIGtr1.appendChild(FIGtd1);FIGtbody.appendChild(FIGtr1);}
  nodeTmp.appendChild(FIGtbody);newFrag.appendChild(nodeTmp);break;case"table":var nodeTmp=document.createElement("table");if(strtmparray[1].search(/\\centering/)>=0){nodeTmp.className='LaTeXtable centered';nodeTmp.align="center";}else{nodeTmp.className='LaTeXtable';};tableid++;nodeTmp.id="LaTeXtable"+tableid;var TABlbl=strtmparray[1].match(/\\label\s*\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\\label\s*\{\w+\}/g,"");var capIndex=strtmparray[1].search(/\\caption\s*\{[\s\S]+\}/);var TABcap="";if(capIndex>=0){var tmp=strtmparray[1];var delimcnt=0;var capstart=-1;for(var pos=capIndex;pos<tmp.length;pos++){if(tmp.charAt(pos)=="{"){delimcnt++};if(tmp.charAt(pos)=="}"){delimcnt--};if(delimcnt==1&&capstart<0){capstart=pos+1};if(delimcnt==0&&capstart>0){capend=pos-1;TABcap=tmp.substring(capstart,pos);break}}}
  if(TABcap!=""){var TABtbody=document.createElement("tbody");var TABcaption=document.createElement("caption");TABcaption.className="LaTeXtable centered";var TABanchor=document.createElement("a");TABanchor.className="LaTeXtable";if(TABlbl!=null){TABanchor.id=TABlbl[1];}
  LaTeXCounter["table"]++;var tabnmbr=makeNumberString(LaTeXCounter["table"]);var anchorSpan=document.createElement("span");anchorSpan.className="LaTeXtable";anchorSpan.style.display="none";anchorSpan.appendChild(document.createTextNode(tabnmbr));TABanchor.appendChild(anchorSpan);TABcaption.appendChild(TABanchor);var TABspan=document.createElement("span");TABspan.className="LaTeXtable";TABspan.appendChild(document.createTextNode("Table "+tabnmbr+". "));TABcaption.appendChild(TABspan);TABcaption.appendChild(document.createTextNode(""+TABcap));nodeTmp.appendChild(TABcaption);}
  var TABinfo=strtmparray[1].match(/\\begin\s*\{\s*tabular\s*\}([\s\S]+)\\end\s*\{\s*tabular\s*\}/);if(TABinfo!=null){var TABtbody=document.createElement('tbody');var TABrow=null;var TABcell=null;var row=0;var col=0;var TABalign=TABinfo[1].match(/^\s*\{([^\}]+)\}/);TABinfo=TABinfo[1].replace(/^\s*\{[^\}]+\}/,"");TABinfo=TABinfo.replace(/\\hline/g,"");TABalign[1]=TABalign[1].replace(/\|/g,"");TABalign[1]=TABalign[1].replace(/\s/g,"");TABinfo=TABinfo.split("\\\\");for(row=0;row<TABinfo.length;row++){TABrow=document.createElement("tr");TABinfo[row]=TABinfo[row].split("&");for(col=0;col<TABinfo[row].length;col++){TABcell=document.createElement("td");switch(TABalign[1].charAt(col)){case"l":TABcell.align="left";break;case"c":TABcell.align="center";break;case"r":TABcell.align="right";break;default:TABcell.align="left";};TABcell.appendChild(document.createTextNode(TABinfo[row][col]));TABrow.appendChild(TABcell);}
  TABtbody.appendChild(TABrow);}
  nodeTmp.appendChild(TABtbody);}
  newFrag.appendChild(nodeTmp);break;case"logicalbreak":var nodeTmp=document.createElement("p");nodeTmp.className=strtmparray[1];nodeTmp.appendChild(document.createTextNode("\u00A0"));newFrag.appendChild(nodeTmp);break;case"appendix":inAppendix=true;sectionCntr=0;break;case"alistitem":var EndDiv=document.createElement("div");EndDiv.className="endlistitem";newFrag.appendChild(EndDiv);var BegDiv=document.createElement("div");BegDiv.className="listitem";if(strtmparray[1]!=" "){var BegSpan=document.createElement("span");BegSpan.className="listitemmarker";var boldBegSpan=document.createElement("b");boldBegSpan.appendChild(document.createTextNode(strtmparray[1]+" "));BegSpan.appendChild(boldBegSpan);BegDiv.appendChild(BegSpan);}
  newFrag.appendChild(BegDiv);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"bibitem":newFrag.appendChild(document.createElement("br"));var nodeTmp=document.createElement("a");nodeTmp.className='bibitem';var nodeSpan=document.createElement("span");nodeSpan.className='bibitem';bibcntr++;var lbl=strtmparray[1].match(/\{\s*(\w+)\s*\}/);strtmparray[1]=strtmparray[1].replace(/\s*\{\s*\w+\s*\}/g,"");strtmparray[1]=strtmparray[1].replace(/^\s*\[/,"");strtmparray[1]=strtmparray[1].replace(/\s*\]$/,"");strtmparray[1]=strtmparray[1].replace(/^\s+|\s+$/g,"");if(lbl==null){biblist[bibcntr]="bibitem"+bibcntr}else{biblist[bibcntr]=lbl[1];};nodeTmp.name=biblist[bibcntr];nodeTmp.id=biblist[bibcntr];if(strtmparray[1]!=""){nodeSpan.appendChild(document.createTextNode(strtmparray[1]));}else{nodeSpan.appendChild(document.createTextNode("["+bibcntr+"]"));}
  nodeTmp.appendChild(nodeSpan);newFrag.appendChild(nodeTmp);break;case"cite":var nodeTmp=document.createElement("a");nodeTmp.className='cite';nodeTmp.name='cite';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;case"ref":var nodeTmp=document.createElement("a");nodeTmp.className='ref';nodeTmp.name='ref';nodeTmp.href="#"+strtmparray[1];newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("div");nodeTmp.className=strtmparray[0];if(IsCounter.test(strtmparray[0])){LaTeXCounter[strtmparray[0]]++;var nodeAnchor=document.createElement("a");nodeAnchor.className=strtmparray[0];var divnum=makeNumberString(LaTeXCounter[strtmparray[0]]);var anchorSpan=document.createElement("span");anchorSpan.className=strtmparray[0];anchorSpan.appendChild(document.createTextNode(divnum));anchorSpan.style.display="none";nodeAnchor.appendChild(anchorSpan);nodeTmp.appendChild(nodeAnchor);var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]+" "+divnum+". "));nodeTmp.appendChild(nodeSpan);}
  if(isIE){if(strtmparray[0]==("thebibliography"||"abstract"||"keyword"||"proof")){var nodeSpan=document.createElement("span");nodeSpan.className=strtmparray[0];nodeSpan.appendChild(document.createTextNode(strtmparray[1]));nodeTmp.appendChild(nodeSpan);}}
  if(strtmparray[0]=="endenumerate"||strtmparray[0]=="enditemize"||strtmparray[0]=="enddescription"){var endDiv=document.createElement("div");endDiv.className="endlistitem";newFrag.appendChild(endDiv);}
  newFrag.appendChild(nodeTmp);if(strtmparray[0]=="enumerate"||strtmparray[0]=="itemize"||strtmparray[0]=="description"){var endDiv=document.createElement("div");endDiv.className="listitem";newFrag.appendChild(endDiv);}}}else{strtmp[j]=strtmp[j].replace(/\\\$/g,"<per>");strtmp[j]=strtmp[j].replace(/\$([^\$]+)\$/g," \\[$1\\[ ");strtmp[j]=strtmp[j].replace(/<per>/g,"\\$");strtmp[j]=strtmp[j].replace(/\\begin\s*\{\s*math\s*\}([\s\S]+?)\\end\s*\{\s*math\s*\}/g," \\[$1\\[ ");var strtmptmp=strtmp[j].split("\\[");for(var jjj=0;jjj<strtmptmp.length;jjj++){if(jjj%2){var nodeTmp=document.createElement("span");nodeTmp.className='inlinemath';nodeTmp.appendChild(document.createTextNode("$"+strtmptmp[jjj]+"$"));newFrag.appendChild(nodeTmp);}else{var TagIndex=strtmptmp[jjj].search(/\\\w+/);var tmpIndex=TagIndex;while(tmpIndex>-1){if(/^\\textcolor/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\textcolor\s*\{\s*(\w+)\s*\}\s*/," \\[textcolor\\]$1\\]|");}else{if(/^\\colorbox/.test(strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length))){strtmptmp[jjj]=strtmptmp[jjj].replace(/\\colorbox\s*\{\s*(\w+)\s*\}\s*/," \\[colorbox\\]$1\\]|");}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).replace(/\\\s*(\w+)\s*/," \\[$1\\]|");}}
  TagIndex+=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\|/);TagIndex++;strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\]\|/,"\\] ");if(strtmptmp[jjj].charAt(TagIndex)=="{"){strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);var delimcnt=1;for(var kk=TagIndex;kk<strtmptmp[jjj].length;kk++){if(strtmptmp[jjj].charAt(kk)=="{"){delimcnt++};if(strtmptmp[jjj].charAt(kk)=="}"){delimcnt--};if(delimcnt==0){break;}}
  strtmptmp[jjj]=strtmptmp[jjj].substring(0,kk)+"\\[ "+strtmptmp[jjj].substring(kk+1,strtmptmp[jjj].length);TagIndex=kk+3;}else{strtmptmp[jjj]=strtmptmp[jjj].substring(0,TagIndex)+"\\[ "+strtmptmp[jjj].substring(TagIndex+1,strtmptmp[jjj].length);TagIndex=TagIndex+3;}
  if(TagIndex<strtmptmp[jjj].length){tmpIndex=strtmptmp[jjj].substring(TagIndex,strtmptmp[jjj].length).search(/\\\w+/);}
  else{tmpIndex=-1};TagIndex+=tmpIndex;}
  strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\\s*\\\\/g,"\\\\");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\\\/g," \\[br\\] \\[ ");strtmptmp[jjj]=strtmptmp[jjj].replace(/\\label\s*\{\s*(\w+)\s*\}/g," \\[a\\]$1\\[ ");var strlbls=strtmptmp[jjj].split("\\[");for(var jj=0;jj<strlbls.length;jj++){if(jj%2){var strtmparray=strlbls[jj].split("\\]");switch(strtmparray[0]){case"textcolor":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.color=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.color=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"colorbox":var nodeTmp=document.createElement("span");nodeTmp.className='LaTeXColor';if(IsColorName.test(strtmparray[1].toLowerCase())){nodeTmp.style.background=LaTeXColor[strtmparray[1].toLowerCase()];}else{nodeTmp.style.background=strtmparray[1];};nodeTmp.appendChild(document.createTextNode(strtmparray[2]));newFrag.appendChild(nodeTmp);break;case"br":newFrag.appendChild(document.createElement("br"));break;case"a":var nodeTmp=document.createElement("a");nodeTmp.className='LaTeXMathMLlabel';nodeTmp.id=strtmparray[1];nodeTmp.style.display="none";newFrag.appendChild(nodeTmp);break;default:var nodeTmp=document.createElement("span");nodeTmp.className=strtmparray[0];nodeTmp.appendChild(document.createTextNode(strtmparray[1]))
  newFrag.appendChild(nodeTmp);}}else{newFrag.appendChild(document.createTextNode(strlbls[jj]));}}}}}}}};TheBody.parentNode.replaceChild(newFrag,TheBody);}}}
  return TheBody;}
  function LaTeXDivsAndRefs(thebody){var TheBody=thebody;var EndDivClass=null;var AllDivs=TheBody.getElementsByTagName("div");var lbl2id="";var lblnode=null;for(var i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){EndDivClass=EndDivClass[0];var DivClass=EndDivClass.substring(3,EndDivClass.length);var EndDivNode=AllDivs[i];break;}}
  while(EndDivClass!=null){var newFrag=document.createDocumentFragment();var RootNode=EndDivNode.parentNode;var ClassCount=1;while(EndDivNode.previousSibling!=null&&ClassCount>0){switch(EndDivNode.previousSibling.className){case EndDivClass:ClassCount++;newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);break;case DivClass:if(EndDivNode.previousSibling.nodeName=="DIV"){ClassCount--;if(lbl2id!=""){EndDivNode.previousSibling.id=lbl2id;lbl2id=""}
  if(ClassCount==0){RootNode=EndDivNode.previousSibling;}else{newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}};break;case'LaTeXMathMLlabel':lbl2id=EndDivNode.previousSibling.id;EndDivNode.parentNode.removeChild(EndDivNode.previousSibling);break;default:newFrag.insertBefore(EndDivNode.previousSibling,newFrag.firstChild);}}
  RootNode.appendChild(newFrag);EndDivNode.parentNode.removeChild(EndDivNode);AllDivs=TheBody.getElementsByTagName("DIV");for(i=AllDivs.length-1;i>=0;i--){EndDivClass=AllDivs[i].className.match(/end\w+/);if(EndDivClass!=null){ClassCount=0;EndDivClass=EndDivClass[0];DivClass=EndDivClass.substring(3,EndDivClass.length);EndDivNode=AllDivs[i];RootNode=EndDivNode.parentNode;break;}}}
  var AllDivs=TheBody.getElementsByTagName("div");var DIV2LI=null;for(var i=0;i<AllDivs.length;i++){if(AllDivs[i].className=="itemize"||AllDivs[i].className=="enumerate"||AllDivs[i].className=="description"){if(AllDivs[i].className=="itemize"){RootNode=document.createElement("UL");}else{RootNode=document.createElement("OL");}
  RootNode.className='LaTeXMathML';if(AllDivs[i].hasChildNodes()){AllDivs[i].removeChild(AllDivs[i].firstChild)};while(AllDivs[i].hasChildNodes()){if(AllDivs[i].firstChild.hasChildNodes()){DIV2LI=document.createElement("LI");while(AllDivs[i].firstChild.hasChildNodes()){DIV2LI.appendChild(AllDivs[i].firstChild.firstChild);}
  if(DIV2LI.firstChild.className=="listitemmarker"){DIV2LI.style.listStyleType="none";}
  RootNode.appendChild(DIV2LI)}
  AllDivs[i].removeChild(AllDivs[i].firstChild);}
  AllDivs[i].appendChild(RootNode);}}
  var AllAnchors=TheBody.getElementsByTagName("a");for(var i=0;i<AllAnchors.length;i++){if(AllAnchors[i].className=="ref"||AllAnchors[i].className=="cite"){var label=AllAnchors[i].href.match(/\#(\w+)/);if(label!=null){var labelNode=document.getElementById(label[1]);if(labelNode!=null){var TheSpans=labelNode.getElementsByTagName("SPAN");if(TheSpans!=null){var refNode=TheSpans[0].cloneNode(true);refNode.style.display="inline"
  refNode.className=AllAnchors[i].className;AllAnchors[i].appendChild(refNode);}}}}}
  return TheBody;}
  var AMbody;var AMnoMathML=false,AMtranslated=false;function translate(spanclassAM){if(!AMtranslated){AMtranslated=true;AMinitSymbols();var LaTeXContainers=[];var AllContainers=document.getElementsByTagName('*');var ExtendName="";for(var k=0,l=0;k<AllContainers.length;k++){ExtendName=" "+AllContainers[k].className+" ";if(ExtendName.match(/\sLaTeX\s/)!=null){LaTeXContainers[l]=AllContainers[k];l++;}};if(LaTeXContainers.length>0){for(var m=0;m<LaTeXContainers.length;m++){AMbody=LaTeXContainers[m];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  if(AMbody.tagName=="PRE"){var PreChilds=document.createDocumentFragment();var DivChilds=document.createElement("DIV");while(AMbody.hasChildNodes()){DivChilds.appendChild(AMbody.firstChild);}
  PreChilds.appendChild(DivChilds);AMbody.parentNode.replaceChild(PreChilds,AMbody);AMbody=DivChilds;}
  AMprocessNode(AMbody,false,spanclassAM);}}else{AMbody=document.getElementsByTagName("body")[0];try{AMbody=LaTeXDivsAndRefs(LaTeXpreProcess(AMbody));}catch(err){alert("Unknown Error: Defaulting to Original LaTeXMathML");}
  AMprocessNode(AMbody,false,spanclassAM);}}}
  if(isIE){document.write("<object id=\"mathplayer\" classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");}
  function generic()
  {translate();};if(typeof window.addEventListener!='undefined')
  {window.addEventListener('load',generic,false);}
  else if(typeof document.addEventListener!='undefined')
  {document.addEventListener('load',generic,false);}
  else if(typeof window.attachEvent!='undefined')
  {window.attachEvent('onload',generic);}
  else
  {if(typeof window.onload=='function')
  {var existing=onload;window.onload=function()
  {existing();generic();};}
  else
  {window.onload=generic;}}
  /*]]>*/
  </script>
  <script src="http://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js.gz"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Feldspar: Functional Embedded Language for DSP and Parallelism</h1>
  <p class="author">
Emil Axelsson
  </p>
  <p class="date">AFP guest lecture, March 2013</p>
</div>
<div class="section slide level1">

<style type="text/css">
ul{
  margin-left:2.3em;
}
</style>



<!--
\begin{code}

{-# LANGUAGE NoMonomorphismRestriction #-}

import Test.QuickCheck

\end{code}
-->



</div>
<div class="section slide level1" id="motivation">
<h1>Motivation</h1>
<p>Feldspar was initiated by Ericsson and Chalmers with the aim to improve development of signal processing software</p>
<p>Why?</p>
<ul>
<li>New telecoms standards require ever-increasing computation power in radio base stations</li>
<li>Limitations on power force movement to more and more parallel hardware</li>
<li>Performance is essential!</li>
<li>Portability is essential!</li>
</ul>
</div>
<div class="section slide level1" id="motivation-1">
<h1>Motivation</h1>
<p>Performance and portability essential</p>
<p>But</p>
<ul>
<li>Fast programs need to be <strong>highly optimized</strong></li>
<li>Optimization means <strong>target-specific</strong></li>
<li>Target-specific means <strong>non-portable</strong></li>
</ul>
<p>And</p>
<ul>
<li>Current signal processing code mostly written in C  <em>not easily parallelized</em></li>
</ul>
</div>
<div class="section slide level1" id="hand-optimized-loop-from-amr-codec">
<h1>Hand-optimized loop (from AMR codec)</h1>
<p>ANSI-C specification:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; L_frame; j++, p++, p1++)
{
   t0 = L_mac (t0, *p, *p1);
}
corr[i] = t0;</code></pre>

<div class="incremental">
  <div class="nonincremental">

<p>Equivalent loop optimized for specific processor:</p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#pragma MUST_ITERATE(80,160,80);</span>
<span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; L_frame; j++)
{
  pj_pj = _pack2 (p[j], p[j]);
  p0_p1 = _mem4_const(&amp;p0[j<span class="dv">+0</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p0_p1);
  t0 = _sadd (t0, _hi (prod0_prod1));
  t1 = _sadd (t1, _lo (prod0_prod1));
  p2_p3 = _mem4_const(&amp;p0[j<span class="dv">+2</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p2_p3);
  t2 = _sadd (t2, _hi (prod0_prod1));
  t3 = _sadd (t3, _lo (prod0_prod1));
  p4_p5 = _mem4_const(&amp;p0[j<span class="dv">+4</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p4_p5);
  t4 = _sadd (t4, _hi (prod0_prod1));
  t5 = _sadd (t5, _lo (prod0_prod1));
  p6_p7 = _mem4_const(&amp;p0[j<span class="dv">+6</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p6_p7);
  t6 = _sadd (t6, _hi (prod0_prod1));
  t7 = _sadd (t7, _lo (prod0_prod1));
}
corr[i] = t0; corr[i<span class="dv">+1</span>] = t1;
corr[i<span class="dv">+2</span>] = t2; corr[i<span class="dv">+3</span>] = t3;
corr[i<span class="dv">+4</span>] = t4; corr[i<span class="dv">+5</span>] = t5;
corr[i<span class="dv">+6</span>] = t6; corr[i<span class="dv">+7</span>] = t7;</code></pre>
<ul>
<li>Pragmas</li>
<li>Intrinsic instructions</li>
<li>Loop unrolling</li>
<li>Etc.</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="hand-optimized-loop-from-amr-codec-1">
<h1>Hand-optimized loop (from AMR codec)</h1>
<p>Hand-optimized version probably not suited for a different processor; <b>non-portable!</b></p>
<pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#pragma MUST_ITERATE(80,160,80);</span>
<span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; L_frame; j++)
{
  pj_pj = _pack2 (p[j], p[j]);
  p0_p1 = _mem4_const(&amp;p0[j<span class="dv">+0</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p0_p1);
  t0 = _sadd (t0, _hi (prod0_prod1));
  t1 = _sadd (t1, _lo (prod0_prod1));
  p2_p3 = _mem4_const(&amp;p0[j<span class="dv">+2</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p2_p3);
  t2 = _sadd (t2, _hi (prod0_prod1));
  t3 = _sadd (t3, _lo (prod0_prod1));
  p4_p5 = _mem4_const(&amp;p0[j<span class="dv">+4</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p4_p5);
  t4 = _sadd (t4, _hi (prod0_prod1));
  t5 = _sadd (t5, _lo (prod0_prod1));
  p6_p7 = _mem4_const(&amp;p0[j<span class="dv">+6</span>]);
  prod0_prod1 = _smpy2 (pj_pj, p6_p7);
  t6 = _sadd (t6, _hi (prod0_prod1));
  t7 = _sadd (t7, _lo (prod0_prod1));
}
corr[i] = t0; corr[i<span class="dv">+1</span>] = t1;
corr[i<span class="dv">+2</span>] = t2; corr[i<span class="dv">+3</span>] = t3;
corr[i<span class="dv">+4</span>] = t4; corr[i<span class="dv">+5</span>] = t5;
corr[i<span class="dv">+6</span>] = t6; corr[i<span class="dv">+7</span>] = t7;</code></pre>
</div>
<div class="section slide level1" id="code-generation">
<h1>Code generation</h1>
<p><u>(Old) Idea</u>: Separate algorithm from optimizations</p>
<ul>
<li>Algorithm defined in a high-level, domain-specific language (DSL)
<ul>
<li>General-purpose languages like Haskell normally not suited to run on embedded targets<br /> Run-time too big, speed not optimal, etc.</li>
</ul></li>
<li>Optimizations defined separately, e.g.using annotations
<ul>
<li>unroll this loop 4 times, run this computation on a separate core</li>
</ul></li>
<li>Code generator produces low-level, optimized code</li>
</ul>

<div class="incremental">
  <div class="nonincremental">

<p>Fast and portable code!</p>
<ul>
<li>Should (ideally) be able to generate the same code as hand-optimized</li>
<li>Only annotations need to be changed when porting to new hardware</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="feldspar-functional-embedded-language-for-dsp-and-parallelism">
<h1>Feldspar  Functional Embedded Language for DSP and PARallelism</h1>
<p>High-level DSL for numeric processing</p>
<p>Embedded in Haskell</p>
<ul>
<li>Implemented as a library in an existing language (host)</li>
<li>Reusing existing infrastructure
<ul>
<li>Parsing</li>
<li>Type checking</li>
<li>Module system</li>
<li>Testing</li>
<li>Packaging/building</li>
<li>Etc.</li>
</ul></li>
</ul>
<p>More info on embedding: [Hudak1998, Elliott2003]</p>
</div>
<div class="section slide level1" id="feldspar-functional-embedded-language-for-dsp-and-parallelism-1">
<h1>Feldspar  Functional Embedded Language for DSP and PARallelism</h1>
<p>Language front-end:</p>
<ul>
<li>Embedded in Haskell</li>
<li>Functional programming style (higher-order functions, polymorphism, etc.)</li>
<li>Open set of domain-specific extra libraries</li>
</ul>

<div class="incremental">
  <div class="nonincremental">

<p>Back-ends:</p>
<ul>
<li>C code (can run on most targets)</li>
<li>Future: LLVM, CUDA, FPGA</li>
<li>Etc.</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="example-distance-between-two-points">
<h1>Example: distance between two points</h1>
<p>File header:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">P</span>
<span class="kw">import</span> <span class="dt">Feldspar</span>                <span class="co">-- Core language</span>
<span class="kw">import</span> <span class="dt">Feldspar.Vector</span>         <span class="co">-- List-like data structure</span>
<span class="kw">import</span> <span class="dt">Feldspar.Compiler</span>       <span class="co">-- C code generator</span></code></pre>

<div class="incremental">
  <div class="nonincremental">

<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Point</span> <span class="fu">=</span> (<span class="dt">Data</span> <span class="dt">Float</span>, <span class="dt">Data</span> <span class="dt">Float</span>)

<span class="ot">dist ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Float</span>
dist (x1,y1) (x2,y2) <span class="fu">=</span> <span class="fu">sqrt</span> (square (x1<span class="fu">-</span>x2) <span class="fu">+</span> square (y1<span class="fu">-</span>y2))
  <span class="kw">where</span>
    square x <span class="fu">=</span> x<span class="fu">*</span>x</code></pre>
<ul>
<li>Removing the word <code>Data</code> gives the same definition in ordinary Haskell</li>
</ul>
<p>(<code>Data</code> is the AST of Feldspar expressions.)</p>

</div>
  </div>



<p><!--

\begin{code}

length  = length
sum     = sum
map     = map
tail    = tail
(...)     = (...)
zipWith = zipWith

force = force

\end{code}

  --></p>
</div>
<div class="section slide level1" id="example-distance-between-two-points-1">
<h1>Example: distance between two points</h1>
<p>Interactive evaluation:</p>
<pre><code>*Main&gt; eval dist (5,10) (8,6)
5.0</code></pre>

<div class="incremental">
  <div class="nonincremental">

<p>Compilation:</p>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile dist
...
<span class="dt">void</span> test(<span class="kw">struct</span> s_float_float_ * v0, <span class="kw">struct</span> s_float_float_ * v1, <span class="dt">float</span> * out)
{
    <span class="dt">float</span> v2;
    <span class="dt">float</span> v3;

    v2 = ((* v0).member1 - (* v1).member1);
    v3 = ((* v0).member2 - (* v1).member2);
    (* out) = sqrtf(((v2 * v2) + (v3 * v3)));
}</code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="functional-dsp">
<h1>Functional DSP</h1>
<p>Typical DSP operations</p>
<ul>
<li>Element-wise multiplication: <span class="LaTeX">$x_i = a_i \cdot b_i$</span></li>
<li>Moving average: <span class="LaTeX">$x_i = \frac{a_{i+1} + a_i}{2}$</span></li>
<li>Scalar product: <span class="LaTeX">$x = \sum{a_i \cdot b_i}$</span></li>
</ul>
<p><br/></p>

<div class="incremental">
  <div class="nonincremental">

<p><strong>Exercise:</strong> Express as Haskell functions</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">elemMult  ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">movingAvg ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">sProd     ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Float</span></code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="functional-dsp-inhaskell-and-feldspar">
<h1>Functional DSP in<br/>Haskell and Feldspar</h1>
<p>Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">elemMult  ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">movingAvg ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">sProd     ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Float</span>

elemMult <span class="kw">as</span> bs <span class="fu">=</span>
movingAvg <span class="kw">as</span>   <span class="fu">=</span>
sProd <span class="kw">as</span> bs    <span class="fu">=</span></code></pre>
</div>
<div class="section slide level1" id="functional-dsp-inhaskell-and-feldspar-1">
<h1>Functional DSP in<br/>Haskell and Feldspar</h1>
<p>Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">elemMult  ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">movingAvg ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">sProd     ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Float</span>

elemMult <span class="kw">as</span> bs <span class="fu">=</span> <span class="fu">zipWith</span> (<span class="fu">*</span>) <span class="kw">as</span> bs
movingAvg <span class="kw">as</span>   <span class="fu">=</span>
sProd <span class="kw">as</span> bs    <span class="fu">=</span></code></pre>
</div>
<div class="section slide level1" id="functional-dsp-inhaskell-and-feldspar-2">
<h1>Functional DSP in<br/>Haskell and Feldspar</h1>
<p>Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">elemMult  ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">movingAvg ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">sProd     ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Float</span>

elemMult <span class="kw">as</span> bs <span class="fu">=</span> <span class="fu">zipWith</span> (<span class="fu">*</span>) <span class="kw">as</span> bs
movingAvg <span class="kw">as</span>   <span class="fu">=</span> <span class="fu">zipWith</span> (\a a&#39; <span class="ot">-&gt;</span> (a<span class="fu">+</span>a&#39;)<span class="fu">/</span><span class="dv">2</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span>
sProd <span class="kw">as</span> bs    <span class="fu">=</span></code></pre>
</div>
<div class="section slide level1" id="functional-dsp-inhaskell-and-feldspar-3">
<h1>Functional DSP in<br/>Haskell and Feldspar</h1>
<p>Haskell:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">elemMult  ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">movingAvg ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>]
<span class="ot">sProd     ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Float</span>

elemMult <span class="kw">as</span> bs <span class="fu">=</span> <span class="fu">zipWith</span> (<span class="fu">*</span>) <span class="kw">as</span> bs
movingAvg <span class="kw">as</span>   <span class="fu">=</span> <span class="fu">zipWith</span> (\a a&#39; <span class="ot">-&gt;</span> (a<span class="fu">+</span>a&#39;)<span class="fu">/</span><span class="dv">2</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span>
sProd <span class="kw">as</span> bs    <span class="fu">=</span> <span class="fu">sum</span> <span class="fu">$</span> <span class="fu">zipWith</span> (<span class="fu">*</span>) <span class="kw">as</span> bs</code></pre>

<div class="incremental">
  <div class="nonincremental">

<p>Feldspar:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">elemMult  ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span>
<span class="ot">movingAvg ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span>
<span class="ot">sProd     ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Float</span>

elemMult <span class="kw">as</span> bs <span class="fu">=</span> <span class="fu">zipWith</span> (<span class="fu">*</span>) <span class="kw">as</span> bs
movingAvg <span class="kw">as</span>   <span class="fu">=</span> <span class="fu">zipWith</span> (\a a&#39; <span class="ot">-&gt;</span> (a<span class="fu">+</span>a&#39;)<span class="fu">/</span><span class="dv">2</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span>
sProd <span class="kw">as</span> bs    <span class="fu">=</span> <span class="fu">sum</span> <span class="fu">$</span> <span class="fu">zipWith</span> (<span class="fu">*</span>) <span class="kw">as</span> bs</code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="vector-library">
<h1>Vector library</h1>
<p>Inspired by Haskells list library:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Vector1</span> a <span class="fu">=</span> <span class="dt">Vector</span> (<span class="dt">Data</span> a)

<span class="fu">length</span><span class="ot">  ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Length</span>
<span class="fu">sum</span><span class="ot">     ::</span> <span class="dt">Numeric</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> (<span class="dt">Data</span> a) <span class="ot">-&gt;</span> <span class="dt">Data</span> a
<span class="fu">map</span><span class="ot">     ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b
<span class="fu">tail</span><span class="ot">    ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a
<span class="ot">(...)   ::</span> <span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> (<span class="dt">Data</span> <span class="dt">Index</span>)
<span class="fu">zipWith</span><span class="ot"> ::</span> (<span class="dt">Syntax</span> b, <span class="dt">Syntax</span> a) <span class="ot">=&gt;</span>
             (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> <span class="dt">Vector</span> c</code></pre>

<div class="incremental">
  <div class="nonincremental">

<p>Example:</p>
<pre><code>*Main&gt; eval (sum $ map (*2) (1...10)) :: Int32
110</code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="modularity">
<h1>Modularity</h1>
<p>Which one is most readable?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">movingAvg ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span>
movingAvg <span class="kw">as</span> <span class="fu">=</span> <span class="fu">zipWith</span> (\a a&#39; <span class="ot">-&gt;</span> (a<span class="fu">+</span>a&#39;)<span class="fu">/</span><span class="dv">2</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span></code></pre>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">movingAvg2 ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span>
movingAvg2 <span class="kw">as</span> <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="fu">zipWith</span> (<span class="fu">+</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span></code></pre>

<div class="incremental">
  <div class="nonincremental">

<p><code>movingAvg</code> is perhaps closer to the specification: <span class="LaTeX">$x_i = \frac{a_{i+1} + a_i}{2}$</span></p>
<p><!--_--></p>

</div>
  <div class="nonincremental">

<p><code>movingAvg2</code> is more modular!</p>
<ul>
<li>Computing result by transforming data in small steps<br/> (data-centric programming)</li>
<li>Reusing existing higher-order functions as much as possible</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="loop-fusion">
<h1>Loop fusion</h1>
<p>Which one is most efficient?</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">movingAvg ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span>
movingAvg <span class="kw">as</span> <span class="fu">=</span> <span class="fu">zipWith</span> (\a a&#39; <span class="ot">-&gt;</span> (a<span class="fu">+</span>a&#39;)<span class="fu">/</span><span class="dv">2</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span></code></pre>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">movingAvg2 ::</span> <span class="dt">Vector1</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Vector1</span> <span class="dt">Float</span>
movingAvg2 <span class="kw">as</span> <span class="fu">=</span> <span class="fu">map</span> (<span class="fu">/</span><span class="dv">2</span>) <span class="fu">$</span> <span class="fu">zipWith</span> (<span class="fu">+</span>) (<span class="fu">tail</span> <span class="kw">as</span>) <span class="kw">as</span></code></pre>
</div>
<div class="section slide level1" id="loop-fusion-1">
<h1>Loop fusion</h1>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile movingAvg
...
<span class="dt">void</span> test(<span class="kw">struct</span> array * v0, <span class="kw">struct</span> array * out)
{
    <span class="dt">uint32_t</span> v2;
    <span class="dt">uint32_t</span> len0;

    v2 = getLength(v0);
    len0 = min((v2 - min(v2, <span class="dv">1</span>)), v2);
    initArray(out, <span class="kw">sizeof</span>(<span class="dt">float</span>), len0);
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v1 = <span class="dv">0</span>; v1 &lt; len0; v1 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,out,v1) = ((at(<span class="dt">float</span>,v0,(v1 + <span class="dv">1</span>))
                           + at(<span class="dt">float</span>,v0,v1)) / <span class="fl">2.</span>0f);
    }
}</code></pre>
</div>
<div class="section slide level1" id="loop-fusion-2">
<h1>Loop fusion</h1>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile movingAvg2
...
<span class="dt">void</span> test(<span class="kw">struct</span> array * v0, <span class="kw">struct</span> array * out)
{
    <span class="dt">uint32_t</span> v2;
    <span class="dt">uint32_t</span> len0;

    v2 = getLength(v0);
    len0 = min((v2 - min(v2, <span class="dv">1</span>)), v2);
    initArray(out, <span class="kw">sizeof</span>(<span class="dt">float</span>), len0);
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v1 = <span class="dv">0</span>; v1 &lt; len0; v1 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,out,v1) = ((at(<span class="dt">float</span>,v0,(v1 + <span class="dv">1</span>))
                           + at(<span class="dt">float</span>,v0,v1)) / <span class="fl">2.</span>0f);
    }
}</code></pre>

<div class="incremental">
  <div class="nonincremental">

<ul>
<li>Both definitions result in the same C code!</li>
<li>Vector operations <em>fused</em> into a single loop</li>
<li>No intermediate data structures</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="loop-fusion-3">
<h1>Loop fusion</h1>
<p>Feldspars vector library guarantees fusion!</p>
<ul>
<li>Predictable compilation</li>
<li>Encourages modular data-centric programming</li>
</ul>
</div>
<div class="section slide level1" id="removing-dynamic-length-checks">
<h1>Removing dynamic length checks</h1>
<p>Assume input vector of length 100:</p>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile (movingAvg -:: newLen <span class="dv">100</span> &gt;-&gt; id)
...
<span class="dt">void</span> test(<span class="kw">struct</span> array * v0, <span class="kw">struct</span> array * out)
{
    initArray(out, <span class="kw">sizeof</span>(<span class="dt">float</span>), <span class="dv">99</span>);
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v1 = <span class="dv">0</span>; v1 &lt; <span class="dv">99</span>; v1 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,out,v1) = ((at(<span class="dt">float</span>,v0,(v1 + <span class="dv">1</span>))
                           + at(<span class="dt">float</span>,v0,v1)) / <span class="fl">2.</span>0f);
    }
}</code></pre>
</div>
<div class="section slide level1" id="more-fusion">
<h1>More fusion</h1>
<p>Two <code>movingAvg</code> filters in sequence:</p>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile (movingAvg . movingAvg -:: newLen <span class="dv">100</span> &gt;-&gt; id)
...
<span class="dt">void</span> test(<span class="kw">struct</span> array * v0, <span class="kw">struct</span> array * out)
{
    initArray(out, <span class="kw">sizeof</span>(<span class="dt">float</span>), <span class="dv">98</span>);
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v1 = <span class="dv">0</span>; v1 &lt; <span class="dv">98</span>; v1 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,out,v1) = ((((at(<span class="dt">float</span>,v0,(v1 + <span class="dv">2</span>))
                             + at(<span class="dt">float</span>,v0,(v1 + <span class="dv">1</span>))) / <span class="fl">2.</span>0f)
                           + ((at(<span class="dt">float</span>,v0,(v1 + <span class="dv">1</span>))
                             + at(<span class="dt">float</span>,v0,v1)) / <span class="fl">2.</span>0f)) / <span class="fl">2.</span>0f);
    }
}</code></pre>
<ul>
<li>Six additions and three divisions per iteration</li>
<li>Fusion leads to recomputation</li>
</ul>
</div>
<div class="section slide level1" id="the-force">
<h1>The force</h1>
<p>Fusion can be prevented using the <code>force</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">force ::</span> <span class="dt">Syntax</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</code></pre>
<ul>
<li>Semantically the identity function</li>
<li>Operationally stores the vector in memory</li>
</ul>
</div>
<div class="section slide level1" id="the-force-1">
<h1>The force</h1>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile (movingAvg . force . movingAvg -:: newLen <span class="dv">100</span> &gt;-&gt; id)
...
    <span class="kw">struct</span> array v8 = {<span class="dv">0</span>};
    ...
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v6 = <span class="dv">0</span>; v6 &lt; <span class="dv">99</span>; v6 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,&amp;v8,v6) = ((at(<span class="dt">float</span>,v0,(v6 + <span class="dv">1</span>))
                           + at(<span class="dt">float</span>,v0,v6)) / <span class="fl">2.</span>0f);
    ...
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v5 = <span class="dv">0</span>; v5 &lt; <span class="dv">98</span>; v5 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,out,v5) = ((at(<span class="dt">float</span>,&amp;v8,(v5 + <span class="dv">1</span>))
                           + at(<span class="dt">float</span>,&amp;v8,v5)) / <span class="fl">2.</span>0f);
    ...</code></pre>
<ul>
<li>Two <code>+</code> and one <code>/</code> per iteration; twice as many iterations</li>
<li>Allocates intermediate array</li>
<li>Trades speed for memory</li>
<li>The user is in control!</li>
</ul>
</div>
<div class="section slide level1" id="code-generation-1">
<h1>Code generation</h1>
<p>Recall: Separate algorithm from optimizations</p>
<ul>
<li>Algorithm defined in a high-level, domain-specific language (DSL)</li>
<li>Optimizations defined separately, e.g.using annotations</li>
<li>Code generator produces low-level, optimized code</li>
</ul>

<div class="incremental">
  <div class="nonincremental">

<p>Feldspar</p>
<ul>
<li>High-level DSL</li>
<li><em>Predictable</em> compilation</li>
<li>Functions like <code>newLen</code> and <code>force</code> act as annotations</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="integration-with-haskell-infrastructure">
<h1>Integration with Haskell infrastructure</h1>
<p>QuickCheck:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">prop_movingAvg ::</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span>
prop_movingAvg a <span class="fu">=</span> P.not (P.null a) <span class="fu">==&gt;</span>
    eval movingAvg a <span class="fu">P.==</span> eval movingAvg2 a</code></pre>
<pre><code>*Main&gt; quickCheck prop_movingAvg2
+++ OK, passed 100 tests.</code></pre>
<ul>
<li>Nice to be embedded!</li>
</ul>
</div>
<div class="section slide level1" id="section">
<h1></h1>
<br/> <br/> <br/> <span style="text-align:center">
<h1>
Part II: Implementation
</h1>
<p></span></p>
</div>
<div class="section slide level1" id="architecture">
<h1>Architecture</h1>
<p><br/></p>
<div class="figure">
<img src="Architecture.png" />
</div>
</div>
<div class="section slide level1" id="architecture-1">
<h1>Architecture</h1>
<p><br/></p>
<div class="figure">
<img src="Architecture123.png" />
</div>
<ol style="list-style-type: decimal">
<li>Abstract syntax tree data type (<code>Data a</code>)</li>
<li>User interface to the core AST</li>
<li>High-level Haskell libraries</li>
</ol>
</div>
<div class="section slide level1" id="core-expressions">
<h1>Core expressions</h1>
<div class="figure">
<img src="Architecture1.png" />
</div>
<p>Feldspar uses a special representation of the AST (see part III)</p>
<p>However, the representation is <em>isomorphic</em> to a recursive data type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Data</span> a
  <span class="kw">where</span>
    <span class="dt">Literal</span><span class="ot">  ::</span> (<span class="fu">...</span>)        <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a
    <span class="dt">Add</span><span class="ot">      ::</span> (<span class="kw">Num</span> a, <span class="fu">...</span>) <span class="ot">=&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a
    <span class="dt">Sub</span><span class="ot">      ::</span> (<span class="kw">Num</span> a, <span class="fu">...</span>) <span class="ot">=&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a
    <span class="dt">Parallel</span><span class="ot"> ::</span> (<span class="fu">...</span>)        <span class="ot">=&gt;</span> <span class="dt">Data</span> <span class="dt">Length</span>
                             <span class="ot">-&gt;</span> (<span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> a) <span class="ot">-&gt;</span> <span class="dt">Data</span> [a]
    <span class="fu">...</span></code></pre>
<ul>
<li>Note the use of <em>higher-order abstract syntax</em> (HOAST) for constructs that introduce variables (<code>ForLoop</code>)</li>
</ul>
</div>
<div class="section slide level1" id="core-language">
<h1>Core language</h1>
<div class="figure">
<img src="Architecture2.png" />
</div>
<p>A large number of primitive functions, e.g:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">not</span><span class="ot">  ::</span> <span class="dt">Data</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Bool</span>
<span class="ot">(&amp;&amp;) ::</span> <span class="dt">Data</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Bool</span>
<span class="ot">(||) ::</span> <span class="dt">Data</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Bool</span>

<span class="fu">div</span><span class="ot"> ::</span> <span class="kw">Integral</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a
<span class="fu">mod</span><span class="ot"> ::</span> <span class="kw">Integral</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> a

<span class="kw">instance</span> <span class="dt">Numeric</span> a <span class="ot">=&gt;</span> <span class="kw">Num</span> (<span class="dt">Data</span> a)
<span class="fu">...</span></code></pre>
<ul>
<li>Many of these functions override the corresponding <code>Prelude</code> functions</li>
</ul>
</div>
<div class="section slide level1" id="core-language-1">
<h1>Core language</h1>
<div class="figure">
<img src="Architecture2.png" />
</div>
<p>Complex constructs:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parallel ::</span> <span class="dt">Type</span> a
    <span class="ot">=&gt;</span> <span class="dt">Data</span> <span class="dt">Length</span>                         <span class="co">-- Length of result</span>
    <span class="ot">-&gt;</span> (<span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> a)              <span class="co">-- Index projection</span>
    <span class="ot">-&gt;</span> <span class="dt">Data</span> [a]                            <span class="co">-- Core language array</span>

<span class="ot">forLoop ::</span> <span class="dt">Type</span> st
    <span class="ot">=&gt;</span> <span class="dt">Data</span> <span class="dt">Length</span>                         <span class="co">-- Number of steps</span>
    <span class="ot">-&gt;</span> <span class="dt">Data</span> st                             <span class="co">-- Initial state</span>
    <span class="ot">-&gt;</span> (<span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> st <span class="ot">-&gt;</span> <span class="dt">Data</span> st)  <span class="co">-- &quot;Body&quot; (single step)</span>
    <span class="ot">-&gt;</span> <span class="dt">Data</span> st                             <span class="co">-- Final state</span></code></pre>
<p>And much more</p>
</div>
<div class="section slide level1" id="core-language-examples">
<h1>Core language: Examples</h1>
<p>Core language version of <code>movingAvg</code>:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">movingAvg3 ::</span> <span class="dt">Data</span> [<span class="dt">Float</span>] <span class="ot">-&gt;</span> <span class="dt">Data</span> [<span class="dt">Float</span>]
movingAvg3 a <span class="fu">=</span> parallel (getLength a <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">$</span> \i <span class="ot">-&gt;</span> (a<span class="fu">!</span>(i<span class="dv">+1</span>) <span class="fu">+</span> a<span class="fu">!</span>i) <span class="fu">/</span> <span class="dv">2</span></code></pre>
<p><!--

\begin{code}
prop_movingAvg2 a = P.not (P.null a) ==> eval movingAvg a P.== eval movingAvg3 a
\end{code}

  --></p>

<div class="incremental">
  <div class="nonincremental">

<p>Same C code as before</p>
<pre class="sourceCode c"><code class="sourceCode c">*Main&gt; icompile (movingAvg3 -:: Feldspar.setLength <span class="dv">100</span> &gt;-&gt; id)
...
<span class="dt">void</span> test(<span class="kw">struct</span> array * v0, <span class="kw">struct</span> array * out)
{
    initArray(out, <span class="kw">sizeof</span>(<span class="dt">float</span>), <span class="dv">99</span>);
    <span class="kw">for</span>(<span class="dt">uint32_t</span> v1 = <span class="dv">0</span>; v1 &lt; <span class="dv">99</span>; v1 += <span class="dv">1</span>)
    {
        at(<span class="dt">float</span>,out,v1) = ((at(<span class="dt">float</span>,v0,(v1 + <span class="dv">1</span>))
                           + at(<span class="dt">float</span>,v0,v1)) / <span class="fl">2.</span>0f);
    }
}</code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="high-level-libraries">
<h1>High-level libraries</h1>
<div class="figure">
<img src="Architecture3.png" />
</div>
<p>The <code>Syntax</code> class abstracts over <code>Data</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Syntax</span> a
  <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Internal</span> a
<span class="ot">    desugar ::</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> (<span class="dt">Internal</span> a)
<span class="ot">    sugar   ::</span> <span class="dt">Data</span> (<span class="dt">Internal</span> a) <span class="ot">-&gt;</span> a

<span class="kw">instance</span> <span class="dt">Type</span> a <span class="ot">=&gt;</span> <span class="dt">Syntax</span> (<span class="dt">Data</span> a)
  <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Internal</span> (<span class="dt">Data</span> a) <span class="fu">=</span> a
    desugar <span class="fu">=</span> <span class="fu">id</span>
    sugar   <span class="fu">=</span> <span class="fu">id</span></code></pre>
</div>
<div class="section slide level1" id="high-level-libraries-1">
<h1>High-level libraries</h1>
<div class="figure">
<img src="Architecture3.png" />
</div>
<p>Vectors are syntactic sugar:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Syntax</span> a <span class="ot">=&gt;</span> <span class="dt">Syntax</span> (<span class="dt">Vector</span> a)
  <span class="kw">where</span>
    <span class="kw">type</span> <span class="dt">Internal</span> (<span class="dt">Vector</span> a) <span class="fu">=</span> [<span class="dt">Internal</span> a]
    <span class="fu">...</span></code></pre>
<p>Tuples are also sugar, etc.</p>
<p><!--
\begin{code}

{-# LANGUAGE GADTs #-}

import qualified Prelude as P
import Feldspar
import qualified Feldspar.Vector as V
import Feldspar.Compiler

\end{code}
  --></p>
</div>
<div class="section slide level1" id="vector-library-1">
<h1>Vector library</h1>
<div class="figure">
<img src="Architecture3.png" />
</div>
<p>Type of vectors:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vector</span> a
  <span class="kw">where</span>
    <span class="dt">Indexed</span><span class="ot"> ::</span> <span class="dt">Data</span> <span class="dt">Length</span> <span class="ot">-&gt;</span> (<span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a

<span class="ot">indexed ::</span> <span class="dt">Data</span> <span class="dt">Length</span> <span class="ot">-&gt;</span> (<span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a
indexed <span class="fu">=</span> <span class="dt">Indexed</span>

<span class="kw">type</span> <span class="dt">Vector1</span> a <span class="fu">=</span> <span class="dt">Vector</span> (<span class="dt">Data</span> a)
<span class="kw">type</span> <span class="dt">Vector2</span> a <span class="fu">=</span> <span class="dt">Vector</span> (<span class="dt">Vector</span> (<span class="dt">Data</span> a))</code></pre>
<p>(The <code>Vector</code> type provided by Feldspar is slightly more complicated.)</p>

<div class="incremental">
  <div class="nonincremental">

<ul>
<li>Implemented using the core language API</li>
<li>Not part of the core expression data type</li>
<li>Guaranteed to be reduced at compile-time</li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="vector-library-2">
<h1>Vector library</h1>
<p>A vector is not a core expression, but it can be turned into one:</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="fu">length</span><span class="ot"> ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Length</span>
<span class="fu">length</span> (<span class="dt">Indexed</span> l _) <span class="fu">=</span> l

<span class="fu">index</span><span class="ot"> ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> a
<span class="fu">index</span> (<span class="dt">Indexed</span> _ ixf) i <span class="fu">=</span> ixf i

<span class="ot">freeze ::</span> <span class="dt">Type</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> (<span class="dt">Data</span> a) <span class="ot">-&gt;</span> <span class="dt">Data</span> [a]
freeze (<span class="dt">Indexed</span> len ixf) <span class="fu">=</span> parallel len ixf

<span class="ot">fold ::</span> <span class="dt">Syntax</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> a
fold f <span class="fu">init</span> b <span class="fu">=</span> forLoop (<span class="fu">length</span> b) <span class="fu">init</span> <span class="fu">$</span>
                  \i st <span class="ot">-&gt;</span> f st (<span class="fu">index</span> b i)</code></pre>
<p><!--
_
  --></p>
<ul>
<li><em>Haskell functions</em> that generate core expressions
<ul>
<li>The polymorphic types <code>a</code> and <code>b</code> are either core expressions or some other high-level type that can be turned into a core expression.</li>
</ul></li>
</ul>
</div>
<div class="section slide level1" id="exercises">
<h1>Exercises</h1>
<p>Define:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">tail</span><span class="ot"> ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a
<span class="fu">tail</span> f (<span class="dt">Indexed</span> l ixf) <span class="fu">=</span> <span class="dt">Indexed</span> <span class="fu">...</span>

<span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b
<span class="fu">map</span> f (<span class="dt">Indexed</span> l ixf) <span class="fu">=</span> <span class="dt">Indexed</span> <span class="fu">...</span>

<span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Data</span> <span class="dt">Length</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a
<span class="fu">take</span> n (<span class="dt">Indexed</span> l ixf) <span class="fu">=</span> <span class="dt">Indexed</span> <span class="fu">...</span>

<span class="fu">zip</span><span class="ot"> ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> <span class="dt">Vector</span> (a,b)
<span class="fu">zip</span> (<span class="dt">Indexed</span> l1 ixf1) (<span class="dt">Indexed</span> l2 ixf2) <span class="fu">=</span> <span class="dt">Indexed</span> <span class="fu">..</span></code></pre>
</div>
<div class="section slide level1" id="vector-fusion-revisited">
<h1>Vector fusion revisited</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">.</span> <span class="fu">map</span> (<span class="fu">+</span><span class="dv">3</span>)</code></pre>

<div class="incremental">
  <div class="nonincremental">

<pre class="sourceCode haskell"><code class="sourceCode haskell">\(<span class="dt">Indexed</span> l ixf) <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="fu">*</span><span class="dv">2</span>) (<span class="fu">map</span> (<span class="fu">+</span><span class="dv">3</span>) (<span class="dt">Indexed</span> l ixf))</code></pre>

</div>
  <div class="nonincremental">

<pre class="sourceCode haskell"><code class="sourceCode haskell">\(<span class="dt">Indexed</span> l ixf) <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="fu">*</span><span class="dv">2</span>) (<span class="dt">Indexed</span> l ((<span class="fu">+</span><span class="dv">3</span>) <span class="fu">.</span> ixf))</code></pre>

</div>
  <div class="nonincremental">

<pre class="sourceCode haskell"><code class="sourceCode haskell">\(<span class="dt">Indexed</span> l ixf) <span class="ot">-&gt;</span> <span class="dt">Indexed</span> l ((<span class="fu">*</span><span class="dv">2</span>) <span class="fu">.</span> ((<span class="fu">+</span><span class="dv">3</span>) <span class="fu">.</span> ixf))</code></pre>

</div>
  <div class="nonincremental">

<pre class="sourceCode haskell"><code class="sourceCode haskell">\(<span class="dt">Indexed</span> l ixf) <span class="ot">-&gt;</span> <span class="dt">Indexed</span> l (((<span class="fu">*</span><span class="dv">2</span>) <span class="fu">.</span> (<span class="fu">+</span><span class="dv">3</span>)) <span class="fu">.</span> ixf)</code></pre>

</div>
  <div class="nonincremental">

<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">map</span> ((<span class="fu">*</span><span class="dv">2</span>) <span class="fu">.</span> (<span class="fu">+</span><span class="dv">3</span>))</code></pre>

</div>
  <div class="nonincremental">

<ul>
<li>Fusion happens in the vector library before any core expression is generated</li>
<li>This is how fusion can be guaranteed!</li>
</ul>

</div>
  </div>


<!--
\begin{code}

import Data.Typeable

\end{code}
-->



</div>
<div class="section slide level1" id="part-iii-syntactic-library">
<h1>Part III: Syntactic library</h1>
<div class="figure">
<img src="Architecture1.png" />
</div>
<p><br/></p>
<p><a href="http://www.cse.chalmers.se/~emax/documents/axelsson2012generic-slides.pdf">Slides</a> from presentation of <em>A generic abstract syntax model for embedded languages</em>, ICFP 2012.</p>
</div>
<div class="section slide level1" id="back-to-feldspar-implementation-of-parallel">
<h1>Back to Feldspar:<br/> Implementation of <code>parallel</code></h1>
<ul>
<li>We will focus on what the Syntactic user has to write</li>
<li>Ignore the magic that happens inside Syntactic</li>
</ul>
</div>
<div class="section slide level1" id="implementation-of-parallel">
<h1>Implementation of <code>parallel</code></h1>
<p>Abstract syntax symbol:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Array</span> a
  <span class="kw">where</span>
    <span class="dt">Parallel</span><span class="ot"> ::</span> <span class="dt">Type</span> a <span class="ot">=&gt;</span> <span class="dt">Array</span>
      (   <span class="dt">Length</span>                 <span class="co">-- Number of elements</span>
      <span class="fu">:-&gt;</span> (<span class="dt">Index</span> <span class="ot">-&gt;</span> a)           <span class="co">-- Index projection</span>
      <span class="fu">:-&gt;</span> <span class="dt">Full</span> [a]               <span class="co">-- Result</span>
      )

    <span class="co">-- Other array constructs omitted</span></code></pre>

<div class="incremental">
  <div class="nonincremental">

<p>User interface (using type-class magic from Syntactic):</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parallel ::</span> <span class="dt">Type</span> a <span class="ot">=&gt;</span>
    <span class="dt">Data</span> <span class="dt">Length</span> <span class="ot">-&gt;</span> (<span class="dt">Data</span> <span class="dt">Index</span> <span class="ot">-&gt;</span> <span class="dt">Data</span> a) <span class="ot">-&gt;</span> <span class="dt">Data</span> [a]
parallel <span class="fu">=</span> sugarSym <span class="dt">Parallel</span></code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="implementation-of-parallel-1">
<h1>Implementation of <code>parallel</code></h1>
<p>Semantics:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Semantic</span> <span class="dt">Array</span>
  <span class="kw">where</span>
    semantics <span class="dt">Parallel</span> <span class="fu">=</span> <span class="dt">Sem</span> <span class="st">&quot;parallel&quot;</span>
        (\len ixf <span class="ot">-&gt;</span> genericTake len <span class="fu">$</span> <span class="fu">map</span> ixf [<span class="dv">0</span><span class="fu">..</span>])</code></pre>

<div class="incremental">
  <div class="nonincremental">

<p><br/></p>
<p>Additionally: optimization, code generation:  30 LOC</p>

</div>
  </div>



</div>
<div class="section slide level1" id="implementation-of-parallel-2">
<h1>Implementation of <code>parallel</code></h1>
<p>Summary: declarative implementation of <code>parallel</code> in  40 LOC</p>
<ul>
<li>Trivial boilerplate code omitted</li>
</ul>

<div class="incremental">
  <div class="nonincremental">

<p>What do we get?</p>
<ul>
<li>Strongly typed abstract and concrete syntax</li>
<li>Interpretations:
<ul>
<li>Evaluation</li>
<li>Syntax tree rendering, etc.</li>
</ul></li>
<li>Transformations
<ul>
<li>Constant folding</li>
<li>Common sub-expression elimination</li>
<li>Invariant code hoisting, etc.</li>
</ul></li>
</ul>

</div>
  </div>



</div>
<div class="section slide level1" id="assembling-the-dsl">
<h1>Assembling the DSL</h1>
<p>Feldspar expression type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Data</span> a <span class="fu">=</span> <span class="dt">Data</span> {<span class="ot"> unData ::</span> <span class="dt">ASTF</span> <span class="dt">FeldDomain</span> a }</code></pre>

<div class="incremental">
  <div class="nonincremental">

<p>The symbol domain:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">FeldDomain</span> a <span class="fu">=</span>
          <span class="dt">FeldDomain</span> (<span class="dt">HODomain</span> <span class="dt">FeldSymbols</span> <span class="dt">Typeable</span> <span class="dt">Type</span> a)

<span class="kw">type</span> <span class="dt">FeldSymbols</span>
    <span class="fu">=</span>   (<span class="dt">Condition</span>  <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Literal</span>    <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Tuple</span>      <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Array</span>      <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Loop</span>       <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">NUM</span>        <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">BITS</span>       <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Complex</span>    <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">...</span></code></pre>

</div>
  </div>



</div>
<div class="section slide level1" id="assembling-the-dsl-1">
<h1>Assembling the DSL</h1>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">FeldSymbols</span>
    <span class="fu">=</span>   (<span class="dt">Condition</span>  <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Literal</span>    <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Tuple</span>      <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Array</span>      <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Loop</span>       <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">NUM</span>        <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">BITS</span>       <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">:+:</span> (<span class="dt">Complex</span>    <span class="fu">:||</span> <span class="dt">Type</span>)
    <span class="fu">...</span></code></pre>
<p>The different features (e.g. <code>Array</code>) are developed independently and assembled in the last minute</p>
<ul>
<li>Simplifying cooperation and experimentation</li>
<li>Enabling reuse across languages</li>
</ul>
</div>
<div class="section slide level1" id="links">
<h1>Links</h1>
<p>Feldspar:</p>
<p><a href="http://hackage.haskell.org/package/feldspar-language">http://hackage.haskell.org/package/feldspar-language</a> <br/> <a href="http://hackage.haskell.org/package/feldspar-compiler">http://hackage.haskell.org/package/feldspar-compiler</a></p>
<p><br/></p>
<p>Syntactic:</p>
<p><a href="http://hackage.haskell.org/package/syntactic">http://hackage.haskell.org/package/syntactic</a></p>
<ul>
<li>Contains a proof-of-concept implementation of Feldspar</li>
</ul>
<pre><code>&gt; cabal unpack syntactic
Downloading syntactic-1.5.2...
Unpacking to syntactic-1.5.2/
&gt; cd syntactic-1.5.2/Examples/NanoFeldspar/</code></pre>
</div>
<div class="section slide level1" id="references">
<h1>References</h1>
<p>Hudak. <em>Modular Domain Specific Languages and Tools</em>.<br/> In ICSR 98: Proceedings of the 5th International Conference on Software Reuse. 1998. IEEE Computer Society.</p>
<p>Elliott, Finne, de Moor. <em>Compiling Embedded Languages</em>.<br/> Journal of Functional Programming. 2003. Cambridge University Press.</p>
</div>
</body>
</html>
